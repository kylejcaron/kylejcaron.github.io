---
layout: post
title:  "Introduction to Surrogate Indexes"
date: "2023-07-09"
categories:
 - experimentation
 - Causal Inference
---

# Introduction
How should you design your experiments if the metric you want to change might take months to observe?

Inspired by [Susan Athey's paper on Surrogate indexes](https://www.nber.org/system/files/working_papers/w26463/w26463.pdf) and another working paper, [Target for Long Term Outcomes](https://ide.mit.edu/wp-content/uploads/2020/12/Targeting-for-long-term-outcomes.pdf?x73880), I've wanted to share my learnings about surrogate indexes for a long time. 

I'm hoping to cover the following in a series of blog posts:

 1. The surrogate index estimator

 2. Surrogate Index in practice
     * Fitting a surrogate index on a realistic dataset
     * Validating the surrogate index over a set of historical experiments

 3. Targeting Long Term Outcomes
     * Optimizing a policy
     * Attempting multi-armed bandits for early optimization

By simulating the data generating process from scratch, I hope this can also be a helpful tool for others to build on so they can answer their own questions they may have about estimating Long Term Treatment Effects.

# Background

__Surrogate indexes__ are an unbiased way to predict a long term treatment effect from an experiment, but of course they're only unbiased if done correctly which is no easy feat.

At Policygenius, customers would take a long time to convert to a sale, and we found that optimizing for middle of the funnel was too easy to game - often we'd have hugely successful experiments that improved the whole top half of the funnel but we wouldn't see any improvement in our true-north metric 6 months later, conversion to sale. Surrogate indexes were a natural way to try and solve that problem. [LinkedIn also has a case study](https://arxiv.org/pdf/2106.01421.pdf) on their need to optimize long term outcomes and how they're using surrogate indexes which is worth a read.

# The Surrogate Index Approach

Surrogate indexes are a way to use short term proxies to estimate long-term treatment effects. For instance, lets say you're a subscription company and you want to see how some intervention improves retention. But churn takes a long time to observe, so your experiment could go on for months. __TLDR;__ is that with this approach, instead of measuring churn as your __overall evaluation criteria (OEC__), you would measure `predicted churn` (with some caveats) as the OEC. 

A common response might be "thats complicated, can we try something more simple for now?" Of course you can. You can always try to choose some single short term proxy as your OEC for an experiment. But be careful because you could end up over-optimizing that proxy and not seeing the improvement in your long term outcome that you want. Surrogate indexes instead have many short term proxies, and they are validated over a set of historical data to ensure they're an unbiased estimator of long term treatment effects.

How do they work? Let's start with a DAG

```{dot}
digraph G {
  X -> S;
  Tx -> S;
  S -> Y;
}
```

DAGs are diagrams, where the arrows represent causal effects. In this case, there's some set of customer features $X$, that influence some set of short term outcomes, $S$ (a surrogate index).

There's also a treatment, $\text{Tx}$, that influences $S$. It may influence different short term outcomes in S in different ways.

Lastly there's $Y$, our long-term outcome of interest. Notice that all of the effect of the treatment on $Y$ flows through $S$. This is saying that the entire causal effect of the treatment on $Y$ is explained by the effect of the treatment on $S$. Keep note of that, because its a key assumption for Surrogate Indexes to work.

A more detailed way to show this is through the use of [IDAGs](https://academic.oup.com/ije/article/50/2/613/5998421), a newer way to represent DAGs with interactions

```{dot}
digraph {
	x [label=X]
	s [label=S]
	y [label=Y]
	t [label=Tx]
	x -> s
	t -> s
	s -> y
	{
		X -> "ΔS_Tx"
		"ΔS_Tx" -> Y
	}
}
```

The IDAG is shown on the right. The main difference is the new term, $\Delta S_{\text{Tx}}$ It implies that $X$ impacts the effect of the treatment on $S$. More simply, the treatment will have different effects on $S$ for different people based on their background, $X$, also known as __heterogeneous treatment effects (HTEs)__.

> Typically we average over HTEs to just get a single average treatment effect (ATE) for experiments, and that's what we'll be doing here. But there are ways to estimate HTEs as well, and we'll get to that in part 3 of this series.

This DAG can be used to build a surrogate index. If you can identify a set, $S$, of shorter term proxies for $Y$, and the effect of the treatment on $Y$ is entirely explained by $S$, than you can use $\hat{Y} = f(S, X, T) + \epsilon$  as an unbiased estimator for $Y$ before $Y$ is actually observed. This also means that you can estimate the long term treatment effect by observing $S$ for each variant of an experiment and using it to predict $\hat{Y}$ for each group, then taking the difference: 
$$
E[\delta_{\text{LTO}}] = E[\hat{Y} | T=1] - E[\hat{Y} | T=0]
$$

where $\delta_{\text{LTO}}$ is the treatment effect on the long term outcome. 

Lets start simulating to see that for ourselves

# Showing that Surrogate Index works with Simulated Data 

## Step 1: Simulating the data
We'll start by simulating two datasets: A historical dataset and an experiment dataset. The advantage to simulating data is that we know the exact effects, so when we try and estimate them we can confirm our methods are recovering the true effect.

```{python}
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import statsmodels.api as sm
from simple_simulation import Transmitter
import scipy.stats as stats
SEED = 99

# step 1: simulate data
Zdims, Xdims, Sdims = 20, 5, 8
transmitter = Transmitter(Zdims=Zdims, Xdims=Xdims, Sdims=Sdims, seed=SEED)

# Simulate data 
historical_data, _ = transmitter.simulate(add_treatment=False, n_users=10000) 
experiment_data, TRUE_EFFECTS = transmitter.simulate(add_treatment=True, n_users=15000) 

# Censor the experiment dataset so that we dont know the long term outcome yet
Y_TRUE = experiment_data.Y.values
experiment_data = experiment_data.assign(Y=np.NaN)

# Show the historical dataset 
display(historical_data.head(5))
```

The underlying simulation code is below if you're interested

```{python}
#| code-fold: true
class TransmitterExample:
    
    def __init__(
        self, 
        Zdims: int, 
        Xdims: int, 
        Sdims: int, 
        logit_link: bool = False,
        seed: int = None
    ) -> None:

        self.rng = np.random.default_rng(seed=seed)
        self.logit_link = logit_link
        self.Zdims, self.Xdims, self.Sdims = Zdims, Xdims, Sdims
        self.params = self._set_true_parameters()
    
    ...

    def simulate(
        self,
        n_users: int = 1,
        add_treatment: bool = False,
        bTS = None,
        bXTS = None,
    ) -> pd.DataFrame:
        '''Simulates outcomes based on some ground truth parameters. 

        Parameters
        -----------
            params: The ground truth parameters (effects and biases) to simulate based off of
            add_treatment: adds a randomly allocated treatment when true, with effect `bTS`
            n_users: The number of users to simulate
            logit_link: whether the data generating process is a bernoulli outcome or not
            rng: A numpy random generator 

        Returns
        --------
            A pandas dataframe with simulated data, including pre-treatment covariates,
             surrogate outcomes, a treatment indicator, and a long term outcome, Y
        '''
        
        def eps(n_users, scale=1):
            return np.random.normal(0, scale, size=n_users)
        
        # unpack params
        alphaX,alphaS,alphaY  = self.params['alphaX'], self.params['alphaS'], self.params['alphaY'] # bias terms
        bZX,bXS,bSY = self.params['bZX'], self.params['bXS'],self.params['bSY'] # causal relationships
        bTS, bXTS = self._simulate_tx(bTS, bXTS) # tx effects

        # unobserved variable Z representing latent customer traits
        Z = np.random.normal(0,1, size=(n_users, self.Zdims))

        # Some observed pre-TX measures
        X = alphaX[:,None].T + (Z @ bZX) + eps((n_users, self.Xdims))

        # Intermediate outcomes
        S = alphaS[:,None].T + (X @ bXS) + eps((n_users, self.Sdims))
        
        # Add in treatment effect if applicable
        T = np.random.binomial(1,0.5,size=n_users) if add_treatment else np.zeros(n_users)        
        avg_tx_term = (bTS * T[:,None])  
        hetergeneous_tx_term = ((X*T[:,None]) @ bXTS.T)
        S += avg_tx_term + hetergeneous_tx_term 

        # long term outcome
        eta = (alphaY[:,None] + (S @ bSY))
            
        # Calculate true treatment effects
        bTY = (bTS @ bSY).ravel()
        eta_scale = eta.std() # TODO: dont estimate eta_scale, calculate it analytically
        ATE = (
            self._approx_expit_expectation(bTY, eta_scale ) 
            - self._approx_expit_expectation(0, eta_scale )
        ) if self.logit_link else bTY
        ground_truth = {"bTS":bTS,"bXTS":bXTS, "bTY":bTY, "ATE":ATE}

        # Long term outcome
        if self.logit_link:
            Y = np.random.binomial(1, sp.expit( eta )) 
        else:
            Y = np.random.normal(eta, .1)

        # Output as dataframe
        Xdf = pd.DataFrame(X, columns=[f'X{i}' for i in range(self.Xdims)]).assign(T=T)
        Sdf = pd.DataFrame(S, columns=[f'S{i}' for i in range(self.Sdims)])
        Ydf = pd.DataFrame(Y.ravel(), columns=['Y'])
        return pd.concat((Xdf, Sdf, Ydf),axis=1), ground_truth
    
```


## Step 2: Fitting a surrogate model 

We'll use the historical dataset to fit the surrogate index model, mapping $S \rightarrow Y$

```{python}
S_vars = " + ".join( historical_data.filter(like="S").columns )
X_vars = " + ".join( historical_data.filter(like="X").columns )

# Step 2: fit a surrogate index model on complete historical data
surrogate_model = sm.OLS.from_formula(f"Y ~ {S_vars}", data=historical_data).fit()

# Estimate the variance in the estimator, \hat{sigma^2}. This is used for bias corrections later
predicted_sigma2 = np.var( surrogate_model.fittedvalues - historical_data.Y,  ddof=1 )

# Show the model summary
surrogate_model.summary()
```


There are 2 important things to note here: 

 1. Note that we're purposely not including the pre-treatment covariates, $X$ in this model. Remember the DAG - all of the effect of $X$ on $Y$ is entirely mediated by $S$, so adding $X$ into the model adds no additional information. 
 2. We're using Ordinary Least Squares. Other nonparametric models can also be swapped in, like Random Forest or XGBoost. 
 3. I'm not doing alot of model validation, just because this is simulated data. In practice, don't just throw things into a model. Part 2 in this series will discuss how to validate surrogate indexes.

## Step 3: Estimate Long Term Treatment Effect

We'll now use the surrogate index to estimate a long term treatment effect

Let's take our experiment dataset and estimate $E[\delta_{\text{LTO}}]$, the average treatment effect on the long term outcome. Notice, the long term outcome, $Y$, hasn't been observed yet.

```{python}
#| code-fold: true
display(experiment_data.head())
```

First, we'll do some visulation of the experiment data.
```{python}
#| code-fold: true
fig, axes = plt.subplots(2,int(Xdims/2),figsize=(8,5),sharey=True)

for i, ax in zip(range(Xdims), axes.ravel()):
    sns.histplot( experiment_data.loc[lambda d: d['T']==0][f"X{i}"],ax=ax, label='Control' )
    sns.histplot( experiment_data.loc[lambda d: d['T']==1][f"X{i}"],ax=ax, label='Treatment' )

plt.suptitle("Histogram of Pre-Treatment Covariates\nfor the Treatment and Control groups")
plt.tight_layout()
```

As we can see above, the pre-treatment variables are the exact same between the experiment groups. Thats because users are randomly allocated into treatment and control groups, and their pre-treatment varibles by definition are things not imapcted by the experiment.

Conversely, if we look at the surrogate outcomes below, we'll see some differences in surrogate outcomes between the treatment and control groups.

```{python}
#| code-fold: true
fig, axes = plt.subplots(2,int(Sdims/2),figsize=(8,5), sharey=True)

for i, ax in zip(range(Sdims), axes.ravel()):
    sns.histplot( experiment_data.loc[lambda d: d['T']==0][f"S{i}"],ax=ax, label='Control' )
    sns.histplot( experiment_data.loc[lambda d: d['T']==1][f"S{i}"],ax=ax, label='Treatment' )

plt.suptitle("Histogram of Surrogate Outcomes\nfor the Treatment and Control groups")
plt.tight_layout()
```

If our surrogate index estimator is correct, these observed surrogate outcomes should directly map to the Long Term Outcome deterministically, via $\hat{Y} = f(S)$, where $f()$ is the surrogate index model. 

We can show that the surrogate index estimator recovers the true average treatment effect on the long term outcome

```{python}
def estimate_delta_LTO(experiment_data, surrogate_model, predicted_sigma2):
    '''Accepts experiment data with a binary treatment, a surrogate model, and the predicted sigma^2 of the surrogate model.
    Returns the ATE estimate and its uncertainty
    
    '''
    Y_T1 = surrogate_model.predict(experiment_data.loc[lambda d: d['T']==1])
    Y_T0 = surrogate_model.predict(experiment_data.loc[lambda d: d['T']==0])
    
    # Calculate the ATE
    ATE =  Y_T1.mean() - Y_T0.mean()
    # calculate the variance 
    var_surrogate = np.var(Y_T1,ddof=1) / len(Y_T1) + np.var(Y_T0,ddof=1) / len(Y_T0)
    # Adjust the variance by the surrogate model error
    var_surrogate_adj = var_surrogate + 2*predicted_sigma2/len(Y_T1)
    ATE_sd = np.sqrt(var_surrogate_adj)
    
    return ATE, ATE_sd

ATE, ATE_sd = estimate_delta_LTO(experiment_data, surrogate_model, predicted_sigma2)
sns.histplot(np.random.normal(ATE, ATE_sd,size=10000), stat='probability')
plt.axvline( TRUE_EFFECTS['ATE'], color='r', ls='--', label='True ATE')
plt.legend()
plt.xlabel("ATE")
plt.title("Estimated Treatment Effect vs. True Treatment Effect")
plt.show()
```

There we are. The surrogate estimator recovers the true average treatment effect! We didn't even have to wait and observe the true long term outcome.

# Repeated Simulation

We can take this a step further and validate it works with repeated simulation. Can it recover true treatment effects? What if there is no effect, does the tests false positive rate match what it should be?

```{python}
transmitter = Transmitter(Zdims=20, Xdims=5, Sdims=8, seed=99)
historical, _ = transmitter.simulate(n_users=10000, add_treatment=False)

S_vars = " + ".join( historical.filter(like="S").columns )
surrogate_model = sm.OLS.from_formula(f"Y ~ {S_vars}", data=historical).fit()
predicted_sigma2 = np.var( surrogate_model.fittedvalues - historical.Y,  ddof=1 )


n_experiments = 1000
alpha=0.05
crit_value = stats.norm(0,1).isf(alpha/2)

in_bounds = []
for i in range(n_experiments):
    
    experiment, TRUTH = transmitter.simulate(n_users=5000, add_treatment=True)

    ate, sd_ate = estimate_delta_LTO(experiment, surrogate_model, predicted_sigma2)
    CI = ate + np.array([-1,1])*crit_value*sd_ate
    
    in_bounds.append([TRUTH['ATE'] >= CI[0] and TRUTH['ATE'] <= CI[1]])

recovery_rate = np.mean(in_bounds)
print("Parameter Recover Rate is {:.1%} (expected: 95%)".format(recovery_rate))
```


```{python}
transmitter = Transmitter(Zdims=20, Xdims=5, Sdims=8, seed=99)
historical, _ = transmitter.simulate(n_users=10000, add_treatment=False)

S_vars = " + ".join( historical.filter(like="S").columns )
surrogate_model = sm.OLS.from_formula(f"Y ~ {S_vars}", data=historical).fit()
predicted_sigma2 = np.var( surrogate_model.fittedvalues - historical.Y,  ddof=1 )


n_experiments = 1000
alpha=0.05
crit_value = stats.norm(0,1).isf(alpha/2)

sigs = []
for i in range(n_experiments):
    
    experiment, TRUTH = transmitter.simulate(
        n_users=5000, 
        add_treatment=True,
        # Force treatment effects to be zero
        bTS=np.zeros((1,8)),
        bXTS=np.zeros((8,5))
    )

    ate, sd_ate = estimate_delta_LTO(experiment, surrogate_model, predicted_sigma2)
    CI = ate + np.array([-1,1]) * crit_value * sd_ate
    
    zero_in_ci = (0 >= CI[0] and 0 <= CI[1])
    sigs.append( [ ~zero_in_ci ] )

sig_result_rate = np.mean(sigs)
print("Empirical False Positive Rate from 1000 trials is {:.1%} (expected: 5%)".format(sig_result_rate))
```



# What's next?

Hopefully this post convinced you that the surrogate index approach can help assess long term outcomes in experiments faster. 

While its easier to show this approach works, it's harder to pull it off in practice. The next post will focus on how to validate a surrogate index estimator on more realistic data that you might see in industry.