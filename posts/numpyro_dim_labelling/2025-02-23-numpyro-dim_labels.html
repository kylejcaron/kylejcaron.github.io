<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.41">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2025-02-23">

<title>Automatic Dim Labelling with Numpyro? – Kyle Caron</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script><script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-7631f81a166a2979f555f02f21929a0e.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-960e14589782da96e8191e666003f35f.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-N3D0DYZCY4"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-N3D0DYZCY4', { 'anonymize_ip': true});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==" crossorigin="anonymous"></script>

<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>


<link rel="stylesheet" href="../../theme.scss">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Kyle Caron</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../blog.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/kylejcaron"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Automatic Dim Labelling with Numpyro?</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">numpyro</div>
                <div class="quarto-category">tensors</div>
                <div class="quarto-category">arviz</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">February 23, 2025</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#part-1-a-simple-regression" id="toc-part-1-a-simple-regression" class="nav-link active" data-scroll-target="#part-1-a-simple-regression">Part 1: A simple regression</a></li>
  <li><a href="#part-2-adding-an-edge-case-multiple-plates-per-site" id="toc-part-2-adding-an-edge-case-multiple-plates-per-site" class="nav-link" data-scroll-target="#part-2-adding-an-edge-case-multiple-plates-per-site">Part 2: Adding an edge case: multiple plates per site</a></li>
  <li><a href="#part-3-what-happens-with-the-zerosumnormal-distribution" id="toc-part-3-what-happens-with-the-zerosumnormal-distribution" class="nav-link" data-scroll-target="#part-3-what-happens-with-the-zerosumnormal-distribution">Part 3: What happens with the ZeroSumNormal distribution</a></li>
  <li><a href="#the-resulting-implementation" id="toc-the-resulting-implementation" class="nav-link" data-scroll-target="#the-resulting-implementation">The resulting implementation</a></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion">Conclusion</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<div id="09d2406a" class="cell" data-execution_count="1">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> typing <span class="im">import</span> Optional, Callable, List, Dict</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpyro</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpyro.distributions <span class="im">as</span> dist</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> numpyro.infer <span class="im">import</span> inspect, Predictive, MCMC, NUTS</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> jaxlib</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> jax</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> jax.numpy <span class="im">as</span> jnp</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> jax <span class="im">import</span> random</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> jaxtyping <span class="im">import</span> Float, Array, Int</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> arviz <span class="im">as</span> az</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>numpyro.set_host_device_count(<span class="dv">2</span>)</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>SEED: <span class="bu">int</span> <span class="op">=</span> <span class="dv">99</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>    <span class="st">"numpyro version:"</span>, numpyro.__version__,</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>    <span class="st">"</span><span class="ch">\n</span><span class="st">jax version:"</span>, jax.__version__,</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>    <span class="st">"</span><span class="ch">\n</span><span class="st">jaxlib version"</span>, jaxlib.__version__,</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>    <span class="st">"</span><span class="ch">\n</span><span class="st">arviz version: "</span>, az.__version__</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>numpyro version: 0.17.0 
jax version: 0.5.0 
jaxlib version 0.5.0 
arviz version:  0.20.0</code></pre>
</div>
</div>
<p>The goal of this post is to figure out how to use numpyro internals to auto-label variable dimensions for arviz. PyMC is heavily integrated with arviz and their dimension labelling is fantastic - I want it to be just as easy with numpyro.</p>
<p>This isn’t necessarily supposed to be a fun blog post, it’s meant to follow my exact thought process as I work through this problem. Maybe that’s helpful for some people? But mostly it will be a good reference for myself in the future.</p>
<section id="part-1-a-simple-regression" class="level1">
<h1>Part 1: A simple regression</h1>
<p>We’ll start with simulating some regression data</p>
<div id="fe79a84e" class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>rng <span class="op">=</span> np.random.default_rng(SEED)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>N, n_feats <span class="op">=</span> <span class="dv">1000</span>, <span class="dv">3</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>z_cardinality <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>alpha <span class="op">=</span> <span class="fl">1.3</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>beta <span class="op">=</span> rng.normal(size<span class="op">=</span>n_feats)</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>gamma <span class="op">=</span> rng.normal(size<span class="op">=</span>z_cardinality)</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>sigma <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> rng.normal(size<span class="op">=</span>(N, n_feats))</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>z <span class="op">=</span> rng.choice(<span class="bu">range</span>(z_cardinality), size<span class="op">=</span>N)</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>mu <span class="op">=</span> alpha <span class="op">+</span> np.dot(X, beta) <span class="op">+</span> gamma[z]</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> rng.normal(mu, sigma)</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a><span class="co"># we'll make a coords dictionary for later</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>coords <span class="op">=</span> {</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Z"</span>: [<span class="ss">f'X</span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">'</span> <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, z_cardinality<span class="op">+</span><span class="dv">1</span>)],</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>    <span class="st">"obs_id"</span>: np.arange(N),</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>    <span class="st">"features"</span>: [<span class="ss">f'X</span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">'</span> <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n_feats<span class="op">+</span><span class="dv">1</span>)],</span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Next, lets fit a linear regression model and try and pass it into arviz to see what happens</p>
<div id="da08d2d0" class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> model(</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    X: Float[Array, <span class="st">"obs features"</span>], </span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    Z: Float[Array, <span class="st">" obs"</span>], </span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    y: Float[Array, <span class="st">" obs"</span>] <span class="op">=</span> <span class="va">None</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> Float[Array, <span class="st">" obs"</span>]:</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    n_features <span class="op">=</span> X.shape[<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    n_groups <span class="op">=</span> <span class="bu">len</span>(np.unique(Z))</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">with</span> numpyro.plate(<span class="st">"Z"</span>, n_groups):</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>        alpha <span class="op">=</span> numpyro.sample(<span class="st">"alpha"</span>, dist.Normal(<span class="dv">0</span>, <span class="dv">3</span>))</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>    sigma <span class="op">=</span> numpyro.sample(<span class="st">"sigma"</span>, dist.HalfNormal(<span class="dv">1</span>))</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">with</span> numpyro.plate(<span class="st">"features"</span>, n_features):</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>        beta <span class="op">=</span> numpyro.sample(<span class="st">"beta"</span>, dist.Normal(<span class="dv">0</span>, <span class="dv">1</span>))</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">with</span> numpyro.plate(<span class="st">"obs_id"</span>, X.shape[<span class="dv">0</span>]):</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>        mu <span class="op">=</span> numpyro.deterministic(<span class="st">"mu"</span>, alpha[z] <span class="op">+</span> jnp.dot(X, beta))</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> numpyro.sample(<span class="st">"y"</span>, dist.Normal(mu, sigma))</span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> run_inference(</span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>    model: Callable,</span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>    key: random.PRNGKey,</span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>    num_warmup: <span class="bu">int</span> <span class="op">=</span> <span class="dv">50</span>, </span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>    num_chains: <span class="bu">int</span> <span class="op">=</span> <span class="dv">2</span>, </span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>    num_samples: <span class="bu">int</span> <span class="op">=</span> <span class="dv">50</span>,</span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>    <span class="op">**</span>kwargs</span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> MCMC:</span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a>    kernel <span class="op">=</span> NUTS(model)</span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a>    mcmc <span class="op">=</span> MCMC(kernel, num_warmup<span class="op">=</span>num_warmup, num_chains<span class="op">=</span>num_chains, num_samples<span class="op">=</span>num_samples, progress_bar<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a>    mcmc.run(key, <span class="op">**</span>kwargs)</span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> mcmc</span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-36"><a href="#cb4-36" aria-hidden="true" tabindex="-1"></a>mcmc <span class="op">=</span> run_inference(model, random.PRNGKey(<span class="dv">0</span>), X<span class="op">=</span>X, Z<span class="op">=</span>z, y<span class="op">=</span>y)</span>
<span id="cb4-37"><a href="#cb4-37" aria-hidden="true" tabindex="-1"></a>idata <span class="op">=</span> az.from_numpyro(mcmc)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now lets inspect the dimensions of a few sites to understand the default behavior</p>
<div id="7bdbf302" class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> print_site_dims(idata, <span class="bu">vars</span> <span class="op">=</span> [<span class="st">'alpha'</span>, <span class="st">'beta'</span>, <span class="st">'mu'</span>]):</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> var <span class="kw">in</span> <span class="bu">vars</span>:</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>var<span class="sc">}</span><span class="ss">:"</span>, idata.posterior[var].dims )</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>print_site_dims(idata)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>alpha: ('chain', 'draw', 'alpha_dim_0')
beta: ('chain', 'draw', 'beta_dim_0')
mu: ('chain', 'draw', 'mu_dim_0')</code></pre>
</div>
</div>
<p>What we really want is for those dimensions labeled “{site}_dim_0” to be labelled by their plate names, so we need to see if there’s a way to automatically grab the plate sizes, and a mapping of which sites correspond to which plates. Luckily there’s an <code>inspect</code> module in numpyro that seems like it might cover some of this!</p>
<div id="ade721d4" class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>model_relations <span class="op">=</span> inspect.get_model_relations(model, model_kwargs<span class="op">=</span><span class="bu">dict</span>(X<span class="op">=</span>X, Z<span class="op">=</span>z, y<span class="op">=</span>y))</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>model_relations</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="5">
<pre><code>{'sample_sample': {'alpha': [],
  'sigma': [],
  'beta': [],
  'mu': ['alpha', 'beta'],
  'y': ['sigma', 'mu']},
 'sample_param': {'alpha': [], 'sigma': [], 'beta': [], 'mu': [], 'y': []},
 'sample_dist': {'alpha': 'Normal',
  'sigma': 'HalfNormal',
  'beta': 'Normal',
  'mu': 'Deterministic',
  'y': 'Normal'},
 'param_constraint': {},
 'plate_sample': {'Z': ['alpha'], 'features': ['beta'], 'obs_id': ['mu', 'y']},
 'observed': []}</code></pre>
</div>
</div>
<p>It looks like `plate_sample has exactly what we need, its just in the wrong order. It should really be formatted as</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    <span class="st">"alpha"</span>: [<span class="st">"Z"</span>]</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    <span class="st">"beta"</span>: [<span class="st">"features"</span>],</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    <span class="st">"mu"</span>: [<span class="st">"obs_id"</span>],</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    <span class="st">"y"</span>: [<span class="st">"obs_id"</span>]</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>All we need to do is make a quick dictionary reversing function</p>
<div id="88dc8366" class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> defaultdict</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> reverse_plate_mapping(plate_mapping: Dict[<span class="bu">str</span>, List[<span class="bu">str</span>]]) <span class="op">-&gt;</span> Dict[<span class="bu">str</span>, List[<span class="bu">str</span>]]:</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    reversed_map <span class="op">=</span> defaultdict(<span class="bu">list</span>)</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> key, values <span class="kw">in</span> plate_mapping.items():</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> value <span class="kw">in</span> values:</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>            reversed_map[value].append(key)</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> reversed_map</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>dims <span class="op">=</span> reverse_plate_mapping(model_relations[<span class="st">'plate_sample'</span>])</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>idata <span class="op">=</span> az.from_numpyro(mcmc, coords<span class="op">=</span>coords, dims<span class="op">=</span>dims)</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>print_site_dims(idata)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>alpha: ('chain', 'draw', 'Z')
beta: ('chain', 'draw', 'features')
mu: ('chain', 'draw', 'obs_id')</code></pre>
</div>
</div>
<p>Perfect! Next lets make sure this works when a site is within multiple plates - I’m concerned that my approach for reversing the plate mapping wont get the order right when a site is within multiple plates</p>
</section>
<section id="part-2-adding-an-edge-case-multiple-plates-per-site" class="level1">
<h1>Part 2: Adding an edge case: multiple plates per site</h1>
<p>We’ll have to simulate some new data. I’m going to make each feature have a group specific effect so that I can test if my solutions will work with nested plates</p>
<div id="c440c95b" class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>beta <span class="op">=</span> rng.normal(size<span class="op">=</span>(z_cardinality, n_feats))</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>mu <span class="op">=</span> alpha <span class="op">+</span> (X <span class="op">*</span> beta[z]).<span class="bu">sum</span>(<span class="op">-</span><span class="dv">1</span>) <span class="op">+</span> gamma[z]</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> rng.normal(mu, sigma)</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> model2(</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    X: Float[Array, <span class="st">"obs features"</span>], </span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>    Z: Float[Array, <span class="st">" obs"</span>], </span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>    y: Float[Array, <span class="st">" obs"</span>] <span class="op">=</span> <span class="va">None</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> Float[Array, <span class="st">" obs"</span>]:</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>    feature_plate <span class="op">=</span> numpyro.plate(<span class="st">"features"</span>, X.shape[<span class="op">-</span><span class="dv">1</span>], dim<span class="op">=-</span><span class="dv">2</span>)</span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>    group_plate <span class="op">=</span> numpyro.plate(<span class="st">"Z"</span>, <span class="bu">len</span>(np.unique(Z)), dim<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">with</span> group_plate:</span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>        alpha <span class="op">=</span> numpyro.sample(<span class="st">"alpha"</span>, dist.Normal(<span class="dv">0</span>, <span class="dv">3</span>))</span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a>    sigma <span class="op">=</span> numpyro.sample(<span class="st">"sigma"</span>, dist.HalfNormal(<span class="dv">1</span>))</span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">with</span> group_plate, feature_plate:</span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a>        beta <span class="op">=</span> numpyro.sample(<span class="st">"beta"</span>, dist.Normal(<span class="dv">0</span>, <span class="dv">1</span>))</span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">with</span> numpyro.plate(<span class="st">"obs_id"</span>, X.shape[<span class="dv">0</span>]):</span>
<span id="cb12-24"><a href="#cb12-24" aria-hidden="true" tabindex="-1"></a>        mu <span class="op">=</span> numpyro.deterministic(<span class="st">"mu"</span>, alpha[z] <span class="op">+</span> (X<span class="op">*</span>beta[:,z].T).<span class="bu">sum</span>(<span class="op">-</span><span class="dv">1</span>))</span>
<span id="cb12-25"><a href="#cb12-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> numpyro.sample(<span class="st">"y"</span>, dist.Normal(mu, sigma))</span>
<span id="cb12-26"><a href="#cb12-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-27"><a href="#cb12-27" aria-hidden="true" tabindex="-1"></a>mcmc <span class="op">=</span> run_inference(model2, random.PRNGKey(<span class="dv">0</span>), X<span class="op">=</span>X, Z<span class="op">=</span>z, y<span class="op">=</span>y)</span>
<span id="cb12-28"><a href="#cb12-28" aria-hidden="true" tabindex="-1"></a>idata <span class="op">=</span> az.from_numpyro(mcmc)</span>
<span id="cb12-29"><a href="#cb12-29" aria-hidden="true" tabindex="-1"></a>print_site_dims(idata)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>alpha: ('chain', 'draw', 'alpha_dim_0')
beta: ('chain', 'draw', 'beta_dim_0', 'beta_dim_1')
mu: ('chain', 'draw', 'mu_dim_0')</code></pre>
</div>
</div>
<div id="3f8e2bbd" class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>model2_relations <span class="op">=</span> inspect.get_model_relations(model2, model_kwargs<span class="op">=</span><span class="bu">dict</span>(X<span class="op">=</span>X, Z<span class="op">=</span>z, y<span class="op">=</span>y))</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>model2_relations</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="8">
<pre><code>{'sample_sample': {'alpha': [],
  'sigma': [],
  'beta': [],
  'mu': ['alpha', 'beta'],
  'y': ['sigma', 'mu']},
 'sample_param': {'alpha': [], 'sigma': [], 'beta': [], 'mu': [], 'y': []},
 'sample_dist': {'alpha': 'Normal',
  'sigma': 'HalfNormal',
  'beta': 'Normal',
  'mu': 'Deterministic',
  'y': 'Normal'},
 'param_constraint': {},
 'plate_sample': {'features': ['beta'],
  'Z': ['alpha', 'beta'],
  'obs_id': ['mu', 'y']},
 'observed': []}</code></pre>
</div>
</div>
<p>This is tricky. Beta should have dims (chain, draw, features, Z), but how do we know the plate_sample dictionary will return the correct order? What happens if we reverse the plate order?</p>
<div id="7db52958" class="cell" data-execution_count="9">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> model2_reversed(</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    X: Float[Array, <span class="st">"obs features"</span>], </span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    Z: Float[Array, <span class="st">" obs"</span>], </span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    y: Float[Array, <span class="st">" obs"</span>] <span class="op">=</span> <span class="va">None</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> Float[Array, <span class="st">" obs"</span>]:</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># reversed the plates</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>    feature_plate <span class="op">=</span> numpyro.plate(<span class="st">"features"</span>, X.shape[<span class="op">-</span><span class="dv">1</span>], dim<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>    group_plate <span class="op">=</span> numpyro.plate(<span class="st">"Z"</span>, <span class="bu">len</span>(np.unique(Z)), dim<span class="op">=-</span><span class="dv">2</span>)</span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">with</span> group_plate:</span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>        alpha <span class="op">=</span> numpyro.sample(<span class="st">"alpha"</span>, dist.Normal(<span class="dv">0</span>, <span class="dv">3</span>))</span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>    sigma <span class="op">=</span> numpyro.sample(<span class="st">"sigma"</span>, dist.HalfNormal(<span class="dv">1</span>))</span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">with</span> feature_plate, group_plate:</span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a>        beta <span class="op">=</span> numpyro.sample(<span class="st">"beta"</span>, dist.Normal(<span class="dv">0</span>, <span class="dv">1</span>))</span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">with</span> numpyro.plate(<span class="st">"obs_id"</span>, X.shape[<span class="dv">0</span>]):</span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true" tabindex="-1"></a>        mu <span class="op">=</span> numpyro.deterministic(<span class="st">"mu"</span>, alpha[z].squeeze(<span class="op">-</span><span class="dv">1</span>) <span class="op">+</span> (X<span class="op">*</span>beta[z]).<span class="bu">sum</span>(<span class="op">-</span><span class="dv">1</span>))</span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> numpyro.sample(<span class="st">"y"</span>, dist.Normal(mu, sigma))</span>
<span id="cb16-21"><a href="#cb16-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-22"><a href="#cb16-22" aria-hidden="true" tabindex="-1"></a>mcmc_reversed <span class="op">=</span> run_inference(model2_reversed, random.PRNGKey(<span class="dv">0</span>), X<span class="op">=</span>X, Z<span class="op">=</span>z, y<span class="op">=</span>y)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="fbcb6103" class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>model2_reversed_relations <span class="op">=</span> inspect.get_model_relations(model2_reversed, model_kwargs<span class="op">=</span><span class="bu">dict</span>(X<span class="op">=</span>X, Z<span class="op">=</span>z, y<span class="op">=</span>y))</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(model2_relations[<span class="st">'plate_sample'</span>])</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(model2_reversed_relations[<span class="st">'plate_sample'</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>{'features': ['beta'], 'Z': ['alpha', 'beta'], 'obs_id': ['mu', 'y']}
{'features': ['beta'], 'Z': ['alpha', 'beta'], 'obs_id': ['mu', 'y']}</code></pre>
</div>
</div>
<p>This is bad news - looking at the plate_samples’s above, we see the same result despite the plates having different dims. This approach isn’t going to maintain the plate order, so we’ll end up mislabelling dims in our previous approach.</p>
<p>I took a closer look at the <a href="https://github.com/pyro-ppl/numpyro/blob/aa829fb85c79bc0dee1c897ec82469aa20b555bb/numpyro/infer/inspect.py#L337"><code>get_model_relations</code></a> function and it looks like this is where they’re pulling plate information</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_model_relations(model, model_args<span class="op">=</span><span class="va">None</span>, model_kwargs<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>    ...</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>    sample_plates <span class="op">=</span> {</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>        name: [frame.name <span class="cf">for</span> frame <span class="kw">in</span> site[<span class="st">"cond_indep_stack"</span>]]</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> name, site <span class="kw">in</span> trace.items()</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> site[<span class="st">"type"</span>] <span class="kw">in</span> [<span class="st">"sample"</span>, <span class="st">"deterministic"</span>]</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>    ...</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>I’m going to try and see what other information is in there by copying their approach of pulling a model trace. Some helper functions are hidden in the code-fold below</p>
<div id="24b9938e" class="cell" data-execution_count="11">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> functools <span class="im">import</span> partial</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> numpyro <span class="im">import</span> handlers</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> numpyro.infer.initialization <span class="im">import</span> init_to_sample</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> numpyro.ops.pytree <span class="im">import</span> PytreeTrace</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>model_kwargs <span class="op">=</span> <span class="bu">dict</span>(X<span class="op">=</span>X, Z<span class="op">=</span>z, y<span class="op">=</span>y)</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> _get_dist_name(fn):</span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">isinstance</span>(</span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>        fn, (dist.Independent, dist.ExpandedDistribution, dist.MaskedDistribution)</span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>    ):</span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> _get_dist_name(fn.base_dist)</span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">type</span>(fn).<span class="va">__name__</span></span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_trace(model, model_kwargs):</span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a>    <span class="co"># We use `init_to_sample` to get around ImproperUniform distribution,</span></span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true" tabindex="-1"></a>    <span class="co"># which does not have `sample` method.</span></span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true" tabindex="-1"></a>    subs_model <span class="op">=</span> handlers.substitute(</span>
<span id="cb20-19"><a href="#cb20-19" aria-hidden="true" tabindex="-1"></a>        handlers.seed(model, <span class="dv">0</span>),</span>
<span id="cb20-20"><a href="#cb20-20" aria-hidden="true" tabindex="-1"></a>        substitute_fn<span class="op">=</span>init_to_sample,</span>
<span id="cb20-21"><a href="#cb20-21" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb20-22"><a href="#cb20-22" aria-hidden="true" tabindex="-1"></a>    trace <span class="op">=</span> handlers.trace(subs_model).get_trace(<span class="op">**</span>model_kwargs)</span>
<span id="cb20-23"><a href="#cb20-23" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Work around an issue where jax.eval_shape does not work</span></span>
<span id="cb20-24"><a href="#cb20-24" aria-hidden="true" tabindex="-1"></a>    <span class="co"># for distribution output (e.g. the function `lambda: dist.Normal(0, 1)`)</span></span>
<span id="cb20-25"><a href="#cb20-25" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Here we will remove `fn` and store its name in the trace.</span></span>
<span id="cb20-26"><a href="#cb20-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> name, site <span class="kw">in</span> trace.items():</span>
<span id="cb20-27"><a href="#cb20-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> site[<span class="st">"type"</span>] <span class="op">==</span> <span class="st">"sample"</span>:</span>
<span id="cb20-28"><a href="#cb20-28" aria-hidden="true" tabindex="-1"></a>            site[<span class="st">"fn_name"</span>] <span class="op">=</span> _get_dist_name(site.pop(<span class="st">"fn"</span>))</span>
<span id="cb20-29"><a href="#cb20-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> site[<span class="st">"type"</span>] <span class="op">==</span> <span class="st">"deterministic"</span>:</span>
<span id="cb20-30"><a href="#cb20-30" aria-hidden="true" tabindex="-1"></a>            site[<span class="st">"fn_name"</span>] <span class="op">=</span> <span class="st">"Deterministic"</span></span>
<span id="cb20-31"><a href="#cb20-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> PytreeTrace(trace)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="76cbef81" class="cell" data-execution_count="12">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>trace <span class="op">=</span> jax.eval_shape(partial(get_trace, model2, model_kwargs)).trace</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>trace[<span class="st">'beta'</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="12">
<pre><code>{'args': (),
 'intermediates': [],
 'value': ShapeDtypeStruct(shape=(3, 10), dtype=float32),
 '_control_flow_done': True,
 'type': 'sample',
 'name': 'beta',
 'kwargs': {'rng_key': None, 'sample_shape': ()},
 'scale': None,
 'is_observed': False,
 'cond_indep_stack': [CondIndepStackFrame(name='features', dim=-2, size=3),
  CondIndepStackFrame(name='Z', dim=-1, size=10)],
 'infer': {},
 'fn_name': 'Normal'}</code></pre>
</div>
</div>
<p>This is perfect! For each site, we can see the plates they are nested within and the dimensions of those plates.</p>
<p>We also see for the reversed model, the order of the plates and the dim values follow a consistent pattern.</p>
<div id="ffa27843" class="cell" data-execution_count="13">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>trace_reversed <span class="op">=</span> jax.eval_shape(partial(get_trace, model2_reversed, model_kwargs)).trace</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>trace_reversed[<span class="st">'beta'</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="13">
<pre><code>{'args': (),
 'intermediates': [],
 'value': ShapeDtypeStruct(shape=(10, 3), dtype=float32),
 '_control_flow_done': True,
 'type': 'sample',
 'name': 'beta',
 'kwargs': {'rng_key': None, 'sample_shape': ()},
 'scale': None,
 'is_observed': False,
 'cond_indep_stack': [CondIndepStackFrame(name='Z', dim=-2, size=10),
  CondIndepStackFrame(name='features', dim=-1, size=3)],
 'infer': {},
 'fn_name': 'Normal'}</code></pre>
</div>
</div>
<p>We should be able to make a working dims mapping from this for each site in our model.</p>
<p>It turns out that they already do this for us on <a href="https://github.com/pyro-ppl/numpyro/blob/aa829fb85c79bc0dee1c897ec82469aa20b555bb/numpyro/infer/inspect.py#L337">L337</a></p>
<div class="sourceCode" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>sample_plates <span class="op">=</span> {</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>    name: [frame.name <span class="cf">for</span> frame <span class="kw">in</span> site[<span class="st">"cond_indep_stack"</span>]]</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> name, site <span class="kw">in</span> trace.items()</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> site[<span class="st">"type"</span>] <span class="kw">in</span> [<span class="st">"sample"</span>, <span class="st">"deterministic"</span>]</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The working implementation is below (but could probably be cleaned up)</p>
<div id="eccfa2b4" class="cell" data-execution_count="14">
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_site_dims(model: Callable, <span class="op">**</span>kwargs):</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _get_dist_name(fn):</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">isinstance</span>(</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>            fn, (dist.Independent, dist.ExpandedDistribution, dist.MaskedDistribution)</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>        ):</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> _get_dist_name(fn.base_dist)</span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">type</span>(fn).<span class="va">__name__</span></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> get_trace():</span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a>        <span class="co"># We use `init_to_sample` to get around ImproperUniform distribution,</span></span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a>        <span class="co"># which does not have `sample` method.</span></span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a>        subs_model <span class="op">=</span> handlers.substitute(</span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true" tabindex="-1"></a>            handlers.seed(model, <span class="dv">0</span>),</span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true" tabindex="-1"></a>            substitute_fn<span class="op">=</span>init_to_sample,</span>
<span id="cb26-15"><a href="#cb26-15" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb26-16"><a href="#cb26-16" aria-hidden="true" tabindex="-1"></a>        trace <span class="op">=</span> handlers.trace(subs_model).get_trace(<span class="op">**</span>kwargs)</span>
<span id="cb26-17"><a href="#cb26-17" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Work around an issue where jax.eval_shape does not work</span></span>
<span id="cb26-18"><a href="#cb26-18" aria-hidden="true" tabindex="-1"></a>        <span class="co"># for distribution output (e.g. the function `lambda: dist.Normal(0, 1)`)</span></span>
<span id="cb26-19"><a href="#cb26-19" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Here we will remove `fn` and store its name in the trace.</span></span>
<span id="cb26-20"><a href="#cb26-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> name, site <span class="kw">in</span> trace.items():</span>
<span id="cb26-21"><a href="#cb26-21" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> site[<span class="st">"type"</span>] <span class="op">==</span> <span class="st">"sample"</span>:</span>
<span id="cb26-22"><a href="#cb26-22" aria-hidden="true" tabindex="-1"></a>                site[<span class="st">"fn_name"</span>] <span class="op">=</span> _get_dist_name(site.pop(<span class="st">"fn"</span>))</span>
<span id="cb26-23"><a href="#cb26-23" aria-hidden="true" tabindex="-1"></a>            <span class="cf">elif</span> site[<span class="st">"type"</span>] <span class="op">==</span> <span class="st">"deterministic"</span>:</span>
<span id="cb26-24"><a href="#cb26-24" aria-hidden="true" tabindex="-1"></a>                site[<span class="st">"fn_name"</span>] <span class="op">=</span> <span class="st">"Deterministic"</span></span>
<span id="cb26-25"><a href="#cb26-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> PytreeTrace(trace)</span>
<span id="cb26-26"><a href="#cb26-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-27"><a href="#cb26-27" aria-hidden="true" tabindex="-1"></a>    <span class="co"># We use eval_shape to avoid any array computation.</span></span>
<span id="cb26-28"><a href="#cb26-28" aria-hidden="true" tabindex="-1"></a>    trace <span class="op">=</span> jax.eval_shape(get_trace).trace</span>
<span id="cb26-29"><a href="#cb26-29" aria-hidden="true" tabindex="-1"></a>    sample_plates <span class="op">=</span> {</span>
<span id="cb26-30"><a href="#cb26-30" aria-hidden="true" tabindex="-1"></a>        name: [frame.name <span class="cf">for</span> frame <span class="kw">in</span> site[<span class="st">"cond_indep_stack"</span>]]</span>
<span id="cb26-31"><a href="#cb26-31" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> name, site <span class="kw">in</span> trace.items()</span>
<span id="cb26-32"><a href="#cb26-32" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> site[<span class="st">"type"</span>] <span class="kw">in</span> [<span class="st">"sample"</span>, <span class="st">"deterministic"</span>]</span>
<span id="cb26-33"><a href="#cb26-33" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb26-34"><a href="#cb26-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> {k:v <span class="cf">for</span> k,v <span class="kw">in</span> sample_plates.items() <span class="cf">if</span> <span class="bu">len</span>(v) <span class="op">&gt;</span> <span class="dv">0</span>}</span>
<span id="cb26-35"><a href="#cb26-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-36"><a href="#cb26-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-37"><a href="#cb26-37" aria-hidden="true" tabindex="-1"></a>idata <span class="op">=</span> az.from_numpyro(</span>
<span id="cb26-38"><a href="#cb26-38" aria-hidden="true" tabindex="-1"></a>    mcmc,</span>
<span id="cb26-39"><a href="#cb26-39" aria-hidden="true" tabindex="-1"></a>    dims<span class="op">=</span>get_site_dims(model2, <span class="op">**</span>model_kwargs),</span>
<span id="cb26-40"><a href="#cb26-40" aria-hidden="true" tabindex="-1"></a>    coords<span class="op">=</span>coords</span>
<span id="cb26-41"><a href="#cb26-41" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb26-42"><a href="#cb26-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-43"><a href="#cb26-43" aria-hidden="true" tabindex="-1"></a>print_site_dims(idata)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>alpha: ('chain', 'draw', 'Z')
beta: ('chain', 'draw', 'features', 'Z')
mu: ('chain', 'draw', 'obs_id')</code></pre>
</div>
</div>
</section>
<section id="part-3-what-happens-with-the-zerosumnormal-distribution" class="level1">
<h1>Part 3: What happens with the ZeroSumNormal distribution</h1>
<p>I recently ported the ZeroSumNormal distribution from <a href="https://www.pymc.io/projects/docs/en/stable/api/distributions/generated/pymc.ZeroSumNormal.html">PyMC</a> to numpyro and it follows some different conventions than the typical distribution.</p>
<p>To understand it, you probably need to have some background on tensor shapes - theres a great blog from <a href="https://ericmjl.github.io/blog/2019/5/29/reasoning-about-shapes-and-probability-distributions/">Eric Ma here</a>.</p>
<p>Typically in numpyro, when we put a sample site within a plate, the <strong>batch shape</strong> is determined by the plates. The batch shape is independent, but not identically distributed across dimensions. For instance in our previous alpha parameter we had 10 groups we stratified it by - we’re getting independent draws for alpha for each group.</p>
<p>The ZeroSumNormal instead works by using an event shape instead of a batch shape. Event shapes often have some dependency across dimensions, and in this case the zero sum constraint creates some dependency across the dimensions.</p>
<p>While we typically might define a categorical parameter like this in numpyro:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> numpyro.plate(<span class="st">"groups"</span>, n_groups):</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>    gamma <span class="op">=</span> numpyro.sample(<span class="st">"gamma"</span>, dist.Normal(<span class="dv">0</span>,<span class="dv">1</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>with the ZeroSumNormal we define categorical parameters like this:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>gamma <span class="op">=</span> numpyro.sample(<span class="st">"gamma"</span>, dist.ZeroSumNormal(<span class="dv">1</span>, event_shape<span class="op">=</span>(n_groups,)))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We need to figure out how to have dims mapped for the ZeroSumNormal despite it not using a plate. The first test will be seeing what happens when we do nest it under a plate</p>
<div id="20a8047d" class="cell" data-execution_count="15">
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> test_model():</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>    n_groups <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">with</span> numpyro.plate(<span class="st">"groups"</span>, n_groups):</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>        gamma <span class="op">=</span> numpyro.sample(<span class="st">"gamma"</span>, dist.ZeroSumNormal(<span class="dv">1</span>, event_shape<span class="op">=</span>(n_groups,)))</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>mcmc <span class="op">=</span> run_inference(test_model, random.PRNGKey(<span class="dv">0</span>), num_chains<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>mcmc.get_samples()[<span class="st">'gamma'</span>].shape</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="15">
<pre><code>(50, 10, 10)</code></pre>
</div>
</div>
<p>It looks like this unfortunately doesnt work, it creates a batch_shape=10, event_shape=10 when we only want the event_shape in this case.</p>
<p>This is going to be a problem that I’m not sure is solve-able with the current tools. But what if we could create a primitive that could save dim names for us in the trace without actually doing anything? ie</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="co"># option 1</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> pseudo_plate(<span class="st">"groups"</span>, n_groups):</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>    gamma <span class="op">=</span> numpyro.sample(<span class="st">"gamma"</span>, dist.ZeroSumNormal(<span class="dv">1</span>, event_shape<span class="op">=</span>(n_groups,)))</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a><span class="co"># option 2</span></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> site_labeller(<span class="st">"groups"</span>):</span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a>    gamma <span class="op">=</span> numpyro.sample(<span class="st">"gamma"</span>, dist.ZeroSumNormal(<span class="dv">1</span>, event_shape<span class="op">=</span>(n_groups,)))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The main idea is that we could store information thats retrieavable in the trace, mimicking plates but without actually expanding the parameter shape like a plate would</p>
<p>Below is an implementation and a quick test model to make sure it has the correct shape saved</p>
<div id="9329a11e" class="cell" data-execution_count="16">
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> numpyro.primitives <span class="im">import</span> Messenger, Message, CondIndepStackFrame</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> pseudo_plate(numpyro.plate):</span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(</span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>,</span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a>        name: <span class="bu">str</span>,</span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a>        size: <span class="bu">int</span>,</span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a>        subsample_size: Optional[<span class="bu">int</span>] <span class="op">=</span> <span class="va">None</span>,</span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a>        dim: Optional[<span class="bu">int</span>] <span class="op">=</span> <span class="va">None</span>,</span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true" tabindex="-1"></a>    ) <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb33-12"><a href="#cb33-12" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.name <span class="op">=</span> name</span>
<span id="cb33-13"><a href="#cb33-13" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.size <span class="op">=</span> size</span>
<span id="cb33-14"><a href="#cb33-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> dim <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span> <span class="kw">and</span> dim <span class="op">&gt;=</span> <span class="dv">0</span>:</span>
<span id="cb33-15"><a href="#cb33-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">"dim arg must be negative."</span>)</span>
<span id="cb33-16"><a href="#cb33-16" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.dim, <span class="va">self</span>._indices <span class="op">=</span> <span class="va">self</span>._subsample(</span>
<span id="cb33-17"><a href="#cb33-17" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.name, <span class="va">self</span>.size, subsample_size, dim</span>
<span id="cb33-18"><a href="#cb33-18" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb33-19"><a href="#cb33-19" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.subsample_size <span class="op">=</span> <span class="va">self</span>._indices.shape[<span class="dv">0</span>]</span>
<span id="cb33-20"><a href="#cb33-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-21"><a href="#cb33-21" aria-hidden="true" tabindex="-1"></a>    <span class="co"># We'll try only adding our pseudoplate to the CondIndepStack without doing anything else</span></span>
<span id="cb33-22"><a href="#cb33-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> process_message(<span class="va">self</span>, msg: Message) <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb33-23"><a href="#cb33-23" aria-hidden="true" tabindex="-1"></a>        cond_indep_stack: <span class="bu">list</span>[CondIndepStackFrame] <span class="op">=</span> msg[<span class="st">"cond_indep_stack"</span>]</span>
<span id="cb33-24"><a href="#cb33-24" aria-hidden="true" tabindex="-1"></a>        frame <span class="op">=</span> CondIndepStackFrame(<span class="va">self</span>.name, <span class="va">self</span>.dim, <span class="va">self</span>.subsample_size)</span>
<span id="cb33-25"><a href="#cb33-25" aria-hidden="true" tabindex="-1"></a>        cond_indep_stack.append(frame)</span>
<span id="cb33-26"><a href="#cb33-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-27"><a href="#cb33-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-28"><a href="#cb33-28" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> test_model():</span>
<span id="cb33-29"><a href="#cb33-29" aria-hidden="true" tabindex="-1"></a>    n_groups <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb33-30"><a href="#cb33-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">with</span> pseudo_plate(<span class="st">"groups"</span>, <span class="dv">0</span>):</span>
<span id="cb33-31"><a href="#cb33-31" aria-hidden="true" tabindex="-1"></a>        gamma <span class="op">=</span> numpyro.sample(<span class="st">"gamma"</span>, dist.ZeroSumNormal(<span class="dv">1</span>, event_shape<span class="op">=</span>(n_groups,)))</span>
<span id="cb33-32"><a href="#cb33-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-33"><a href="#cb33-33" aria-hidden="true" tabindex="-1"></a>mcmc <span class="op">=</span> run_inference(test_model, random.PRNGKey(<span class="dv">0</span>), num_chains<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb33-34"><a href="#cb33-34" aria-hidden="true" tabindex="-1"></a>mcmc.get_samples()[<span class="st">'gamma'</span>].shape</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="16">
<pre><code>(50, 10)</code></pre>
</div>
</div>
<p>As we can see above, we got the correct shape for gamma. Lets see if this works in a model</p>
<div id="b1485899" class="cell" data-execution_count="17">
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> model3(</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>    X: Float[Array, <span class="st">"obs features"</span>], </span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>    Z: Float[Array, <span class="st">" obs"</span>], </span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>    y: Float[Array, <span class="st">" obs"</span>] <span class="op">=</span> <span class="va">None</span>,</span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>    try_pseudo_plate <span class="op">=</span> <span class="va">True</span>,</span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> Float[Array, <span class="st">" obs"</span>]:</span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a>    feature_plate <span class="op">=</span> numpyro.plate(<span class="st">"features"</span>, X.shape[<span class="op">-</span><span class="dv">1</span>], dim<span class="op">=-</span><span class="dv">2</span>)</span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a>    group_plate <span class="op">=</span> numpyro.plate(<span class="st">"Z"</span>, <span class="bu">len</span>(np.unique(Z)), dim<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb35-11"><a href="#cb35-11" aria-hidden="true" tabindex="-1"></a>    alpha <span class="op">=</span> numpyro.sample(<span class="st">"alpha"</span>, dist.Normal(<span class="dv">0</span>, <span class="dv">3</span>))</span>
<span id="cb35-12"><a href="#cb35-12" aria-hidden="true" tabindex="-1"></a>    sigma <span class="op">=</span> numpyro.sample(<span class="st">"sigma"</span>, dist.HalfNormal(<span class="dv">1</span>))</span>
<span id="cb35-13"><a href="#cb35-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">with</span> group_plate, feature_plate:</span>
<span id="cb35-14"><a href="#cb35-14" aria-hidden="true" tabindex="-1"></a>        beta <span class="op">=</span> numpyro.sample(<span class="st">"beta"</span>, dist.Normal(<span class="dv">0</span>, <span class="dv">1</span>))</span>
<span id="cb35-15"><a href="#cb35-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> try_pseudo_plate:</span>
<span id="cb35-16"><a href="#cb35-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">with</span> pseudo_plate(<span class="st">"groups"</span>, <span class="dv">0</span>):</span>
<span id="cb35-17"><a href="#cb35-17" aria-hidden="true" tabindex="-1"></a>            gamma <span class="op">=</span> numpyro.sample(<span class="st">"gamma"</span>, dist.ZeroSumNormal(<span class="dv">1</span>, event_shape<span class="op">=</span>(group_plate.size,)))</span>
<span id="cb35-18"><a href="#cb35-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb35-19"><a href="#cb35-19" aria-hidden="true" tabindex="-1"></a>        gamma <span class="op">=</span> numpyro.sample(<span class="st">"gamma"</span>, dist.ZeroSumNormal(<span class="dv">1</span>, event_shape<span class="op">=</span>(group_plate.size,)))</span>
<span id="cb35-20"><a href="#cb35-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-21"><a href="#cb35-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">with</span> numpyro.plate(<span class="st">"obs_id"</span>, X.shape[<span class="dv">0</span>]):</span>
<span id="cb35-22"><a href="#cb35-22" aria-hidden="true" tabindex="-1"></a>        mu <span class="op">=</span> numpyro.deterministic(<span class="st">"mu"</span>, alpha <span class="op">+</span> gamma[z] <span class="op">+</span> (X<span class="op">*</span>beta[:,z].T).<span class="bu">sum</span>(<span class="op">-</span><span class="dv">1</span>))</span>
<span id="cb35-23"><a href="#cb35-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> numpyro.sample(<span class="st">"y"</span>, dist.Normal(mu, sigma), obs<span class="op">=</span>y)</span>
<span id="cb35-24"><a href="#cb35-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-25"><a href="#cb35-25" aria-hidden="true" tabindex="-1"></a>mcmc_zsn_pseudoplate <span class="op">=</span> run_inference(model3, random.PRNGKey(<span class="dv">0</span>), num_chains<span class="op">=</span><span class="dv">2</span>, num_warmup<span class="op">=</span><span class="dv">1000</span>, num_samples<span class="op">=</span><span class="dv">1000</span>, <span class="op">**</span>model_kwargs)</span>
<span id="cb35-26"><a href="#cb35-26" aria-hidden="true" tabindex="-1"></a>idata_zsn_pseudoplate <span class="op">=</span> az.from_numpyro(</span>
<span id="cb35-27"><a href="#cb35-27" aria-hidden="true" tabindex="-1"></a>    mcmc_zsn_pseudoplate,</span>
<span id="cb35-28"><a href="#cb35-28" aria-hidden="true" tabindex="-1"></a>    dims<span class="op">=</span>get_site_dims(model3, <span class="op">**</span>model_kwargs),</span>
<span id="cb35-29"><a href="#cb35-29" aria-hidden="true" tabindex="-1"></a>    coords<span class="op">=</span>coords</span>
<span id="cb35-30"><a href="#cb35-30" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb35-31"><a href="#cb35-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-32"><a href="#cb35-32" aria-hidden="true" tabindex="-1"></a>print_site_dims(idata_zsn_pseudoplate, <span class="bu">vars</span><span class="op">=</span>[<span class="st">'alpha'</span>, <span class="st">'beta'</span>, <span class="st">'gamma'</span>, <span class="st">'mu'</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>alpha: ('chain', 'draw')
beta: ('chain', 'draw', 'features', 'Z')
gamma: ('chain', 'draw', 'groups')
mu: ('chain', 'draw', 'obs_id')</code></pre>
</div>
</div>
<p>This seemed to work! But are there any unintended consequences of having another “plate” in the <code>CondIndepStack</code>? Lets fit a second version of the model without the pseudo_plate and see if they return similar results</p>
<div id="12ca6bc5" class="cell" data-execution_count="18">
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>mcmc_zsn <span class="op">=</span> run_inference(model3, random.PRNGKey(<span class="dv">0</span>), num_chains<span class="op">=</span><span class="dv">2</span>, num_warmup<span class="op">=</span><span class="dv">1000</span>, num_samples<span class="op">=</span><span class="dv">1000</span>, <span class="op">**</span>model_kwargs, try_pseudo_plate<span class="op">=</span><span class="va">False</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We’ll check that parameter estimation for the site is the same</p>
<div id="5c47784e" class="cell" data-execution_count="19">
<div class="sourceCode cell-code" id="cb38"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>az.plot_forest(</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>    [mcmc_zsn_pseudoplate, mcmc_zsn],</span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>    model_names<span class="op">=</span>[<span class="st">'With Pseudo Plate'</span>, <span class="st">'Without Pseudo Plate'</span>],</span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>     var_names<span class="op">=</span>[<span class="st">'gamma'</span>]</span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Gamma Estimates Across both Models"</span>)</span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="2025-02-23-numpyro-dim_labels_files/figure-html/cell-20-output-1.png" width="572" height="732" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>And more importantly, we’ll make sure this doesnt impact the final likelihood estimate</p>
<div id="7bf31a50" class="cell" data-execution_count="20">
<div class="sourceCode cell-code" id="cb39"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>idata_zsn_pseudoplate <span class="op">=</span> az.from_numpyro(mcmc_zsn_pseudoplate)</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>idata_zsn <span class="op">=</span> az.from_numpyro(mcmc_zsn)</span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>delta <span class="op">=</span> idata_zsn.log_likelihood[<span class="st">'y'</span>] <span class="op">-</span> idata_zsn_pseudoplate.log_likelihood[<span class="st">'y'</span>]</span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Difference in Log Likelihood with and without the pseudoplate:"</span>, <span class="bu">float</span>(delta.mean()))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Difference in Log Likelihood with and without the pseudoplate: 0.0</code></pre>
</div>
</div>
<p>I’m a bit shocked to say that this works so far. Next we need to make sure it works if we have a batch dimension</p>
<div id="4ce780ca" class="cell" data-execution_count="21">
<div class="sourceCode cell-code" id="cb41"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> test_model_batches():</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>    n_groups <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">with</span> pseudo_plate(<span class="st">"groups"</span>, n_groups), numpyro.plate(<span class="st">"batches"</span>, <span class="dv">3</span>):</span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>        gamma <span class="op">=</span> numpyro.sample(<span class="st">"gamma"</span>, dist.ZeroSumNormal(<span class="dv">1</span>, event_shape<span class="op">=</span>(n_groups,)))</span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a>trace <span class="op">=</span> jax.eval_shape(partial(get_trace, test_model_batches, model_kwargs<span class="op">=</span>{})).trace</span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a>trace[<span class="st">'gamma'</span>][<span class="st">'value'</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="21">
<pre><code>ShapeDtypeStruct(shape=(3, 1, 10), dtype=float32)</code></pre>
</div>
</div>
<p>Sadly this didnt quite work - it seems like the dim-handling isn’t working as we want it to because the batch shape is (3,1) instead of just (3,) - this is because of the way we aranged the plates, we put the batches in the position of dim=-2. Lets look at the trace</p>
<div id="82e6bb6e" class="cell" data-execution_count="22">
<div class="sourceCode cell-code" id="cb43"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>trace[<span class="st">'gamma'</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="22">
<pre><code>{'args': (),
 'intermediates': [],
 'value': ShapeDtypeStruct(shape=(3, 1, 10), dtype=float32),
 '_control_flow_done': True,
 'type': 'sample',
 'name': 'gamma',
 'kwargs': {'rng_key': None, 'sample_shape': ()},
 'scale': None,
 'is_observed': False,
 'cond_indep_stack': [CondIndepStackFrame(name='batches', dim=-2, size=3),
  CondIndepStackFrame(name='groups', dim=-1, size=10)],
 'infer': {},
 'fn_name': 'ZeroSumNormal'}</code></pre>
</div>
</div>
<p>Taking a step back, it’s clear I thought about this wrong - the Conditional Indepdence Stack is for batch dimensions that are conditionally independent, and by putting our pseudoplate in there, we’re messing with how the batch dimensions are arranged.</p>
<p>This approach might also be unstable over future versions its a bit like working with a private method - I’m not sure that consistency is guaranteed over minor package releases. It’s also hard to follow exactly how the conditional indepence stack is used throughout the code, and if that will have any unexpected consequences.</p>
<p>I’m going to try something new - lets make a new primitive that creates a <code>dep_stack</code> and we’ll put the pseudo plates in there and see if it fixes things</p>
<div id="324cb509" class="cell" data-execution_count="23">
<div class="sourceCode cell-code" id="cb45"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> typing <span class="im">import</span> Tuple</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> namedtuple</span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpyro</span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> numpyro.primitives <span class="im">import</span> Messenger, Message, apply_stack, _subsample_fn</span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> numpyro.util <span class="im">import</span> find_stack_level</span>
<span id="cb45-7"><a href="#cb45-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-8"><a href="#cb45-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-9"><a href="#cb45-9" aria-hidden="true" tabindex="-1"></a>DepStackFrame <span class="op">=</span> namedtuple(<span class="st">"DepStackFrame"</span>, [<span class="st">"name"</span>, <span class="st">"dim"</span>, <span class="st">"size"</span>])</span>
<span id="cb45-10"><a href="#cb45-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-11"><a href="#cb45-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-12"><a href="#cb45-12" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> pseudo_plate(numpyro.plate):</span>
<span id="cb45-13"><a href="#cb45-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb45-14"><a href="#cb45-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(</span>
<span id="cb45-15"><a href="#cb45-15" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>,</span>
<span id="cb45-16"><a href="#cb45-16" aria-hidden="true" tabindex="-1"></a>        name: <span class="bu">str</span>,</span>
<span id="cb45-17"><a href="#cb45-17" aria-hidden="true" tabindex="-1"></a>        size: <span class="bu">int</span>,</span>
<span id="cb45-18"><a href="#cb45-18" aria-hidden="true" tabindex="-1"></a>        subsample_size: Optional[<span class="bu">int</span>] <span class="op">=</span> <span class="va">None</span>,</span>
<span id="cb45-19"><a href="#cb45-19" aria-hidden="true" tabindex="-1"></a>        dim: Optional[<span class="bu">int</span>] <span class="op">=</span> <span class="va">None</span>,</span>
<span id="cb45-20"><a href="#cb45-20" aria-hidden="true" tabindex="-1"></a>    ) <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb45-21"><a href="#cb45-21" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.name <span class="op">=</span> name</span>
<span id="cb45-22"><a href="#cb45-22" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.size <span class="op">=</span> size</span>
<span id="cb45-23"><a href="#cb45-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> dim <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span> <span class="kw">and</span> dim <span class="op">&gt;=</span> <span class="dv">0</span>:</span>
<span id="cb45-24"><a href="#cb45-24" aria-hidden="true" tabindex="-1"></a>            <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">"dim arg must be negative."</span>)</span>
<span id="cb45-25"><a href="#cb45-25" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.dim, <span class="va">self</span>._indices <span class="op">=</span> <span class="va">self</span>._subsample(</span>
<span id="cb45-26"><a href="#cb45-26" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.name, <span class="va">self</span>.size, subsample_size, dim</span>
<span id="cb45-27"><a href="#cb45-27" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb45-28"><a href="#cb45-28" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.subsample_size <span class="op">=</span> <span class="va">self</span>._indices.shape[<span class="dv">0</span>]</span>
<span id="cb45-29"><a href="#cb45-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-30"><a href="#cb45-30" aria-hidden="true" tabindex="-1"></a>    <span class="co"># We'll try only adding our pseudoplate to the CondIndepStack without doing anything else</span></span>
<span id="cb45-31"><a href="#cb45-31" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> process_message(<span class="va">self</span>, msg: Message) <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb45-32"><a href="#cb45-32" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> msg[<span class="st">"type"</span>] <span class="kw">not</span> <span class="kw">in</span> (<span class="st">"param"</span>, <span class="st">"sample"</span>, <span class="st">"plate"</span>, <span class="st">"deterministic"</span>):</span>
<span id="cb45-33"><a href="#cb45-33" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> msg[<span class="st">"type"</span>] <span class="op">==</span> <span class="st">"control_flow"</span>:</span>
<span id="cb45-34"><a href="#cb45-34" aria-hidden="true" tabindex="-1"></a>                <span class="cf">raise</span> <span class="pp">NotImplementedError</span>(</span>
<span id="cb45-35"><a href="#cb45-35" aria-hidden="true" tabindex="-1"></a>                    <span class="st">"Cannot use control flow primitive under a `plate` primitive."</span></span>
<span id="cb45-36"><a href="#cb45-36" aria-hidden="true" tabindex="-1"></a>                    <span class="st">" Please move those `plate` statements into the control flow"</span></span>
<span id="cb45-37"><a href="#cb45-37" aria-hidden="true" tabindex="-1"></a>                    <span class="st">" body function. See `scan` documentation for more information."</span></span>
<span id="cb45-38"><a href="#cb45-38" aria-hidden="true" tabindex="-1"></a>                )</span>
<span id="cb45-39"><a href="#cb45-39" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span></span>
<span id="cb45-40"><a href="#cb45-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-41"><a href="#cb45-41" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (</span>
<span id="cb45-42"><a href="#cb45-42" aria-hidden="true" tabindex="-1"></a>            <span class="st">"block_plates"</span> <span class="kw">in</span> msg.get(<span class="st">"infer"</span>, {})</span>
<span id="cb45-43"><a href="#cb45-43" aria-hidden="true" tabindex="-1"></a>            <span class="kw">and</span> <span class="va">self</span>.name <span class="kw">in</span> msg[<span class="st">"infer"</span>][<span class="st">"block_plates"</span>]</span>
<span id="cb45-44"><a href="#cb45-44" aria-hidden="true" tabindex="-1"></a>        ):</span>
<span id="cb45-45"><a href="#cb45-45" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span></span>
<span id="cb45-46"><a href="#cb45-46" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb45-47"><a href="#cb45-47" aria-hidden="true" tabindex="-1"></a>        frame <span class="op">=</span> DepStackFrame(<span class="va">self</span>.name, <span class="va">self</span>.dim, <span class="va">self</span>.subsample_size)</span>
<span id="cb45-48"><a href="#cb45-48" aria-hidden="true" tabindex="-1"></a>        msg[<span class="st">'dep_stack'</span>] <span class="op">=</span> msg.get(<span class="st">'dep_stack'</span>, []) <span class="op">+</span> [frame]</span>
<span id="cb45-49"><a href="#cb45-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-50"><a href="#cb45-50" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _get_event_shape(<span class="va">self</span>, dep_stack: List[DepStackFrame]) <span class="op">-&gt;</span> Tuple[<span class="bu">int</span>]:</span>
<span id="cb45-51"><a href="#cb45-51" aria-hidden="true" tabindex="-1"></a>        n_dims <span class="op">=</span> <span class="bu">max</span>(<span class="op">-</span>f.dim <span class="cf">for</span> f <span class="kw">in</span> dep_stack)</span>
<span id="cb45-52"><a href="#cb45-52" aria-hidden="true" tabindex="-1"></a>        event_shape <span class="op">=</span> [<span class="dv">1</span>] <span class="op">*</span> n_dims</span>
<span id="cb45-53"><a href="#cb45-53" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> f <span class="kw">in</span> dep_stack:</span>
<span id="cb45-54"><a href="#cb45-54" aria-hidden="true" tabindex="-1"></a>            event_shape[f.dim] <span class="op">=</span> f.size</span>
<span id="cb45-55"><a href="#cb45-55" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">tuple</span>(event_shape)</span>
<span id="cb45-56"><a href="#cb45-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-57"><a href="#cb45-57" aria-hidden="true" tabindex="-1"></a>    <span class="co"># We need to make sure dims get aranged properly when there are multiple plates</span></span>
<span id="cb45-58"><a href="#cb45-58" aria-hidden="true" tabindex="-1"></a>    <span class="at">@staticmethod</span></span>
<span id="cb45-59"><a href="#cb45-59" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _subsample(name, size, subsample_size, dim):</span>
<span id="cb45-60"><a href="#cb45-60" aria-hidden="true" tabindex="-1"></a>        msg <span class="op">=</span> {</span>
<span id="cb45-61"><a href="#cb45-61" aria-hidden="true" tabindex="-1"></a>            <span class="st">"type"</span>: <span class="st">"plate"</span>,</span>
<span id="cb45-62"><a href="#cb45-62" aria-hidden="true" tabindex="-1"></a>            <span class="st">"fn"</span>: _subsample_fn,</span>
<span id="cb45-63"><a href="#cb45-63" aria-hidden="true" tabindex="-1"></a>            <span class="st">"name"</span>: name,</span>
<span id="cb45-64"><a href="#cb45-64" aria-hidden="true" tabindex="-1"></a>            <span class="st">"args"</span>: (size, subsample_size),</span>
<span id="cb45-65"><a href="#cb45-65" aria-hidden="true" tabindex="-1"></a>            <span class="st">"kwargs"</span>: {<span class="st">"rng_key"</span>: <span class="va">None</span>},</span>
<span id="cb45-66"><a href="#cb45-66" aria-hidden="true" tabindex="-1"></a>            <span class="st">"value"</span>: (</span>
<span id="cb45-67"><a href="#cb45-67" aria-hidden="true" tabindex="-1"></a>                <span class="va">None</span></span>
<span id="cb45-68"><a href="#cb45-68" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> (subsample_size <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span> <span class="kw">and</span> size <span class="op">!=</span> subsample_size)</span>
<span id="cb45-69"><a href="#cb45-69" aria-hidden="true" tabindex="-1"></a>                <span class="cf">else</span> jnp.arange(size)</span>
<span id="cb45-70"><a href="#cb45-70" aria-hidden="true" tabindex="-1"></a>            ),</span>
<span id="cb45-71"><a href="#cb45-71" aria-hidden="true" tabindex="-1"></a>            <span class="st">"scale"</span>: <span class="fl">1.0</span>,</span>
<span id="cb45-72"><a href="#cb45-72" aria-hidden="true" tabindex="-1"></a>            <span class="st">"cond_indep_stack"</span>: [],</span>
<span id="cb45-73"><a href="#cb45-73" aria-hidden="true" tabindex="-1"></a>            <span class="st">"dep_stack"</span>: [],</span>
<span id="cb45-74"><a href="#cb45-74" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb45-75"><a href="#cb45-75" aria-hidden="true" tabindex="-1"></a>        apply_stack(msg)</span>
<span id="cb45-76"><a href="#cb45-76" aria-hidden="true" tabindex="-1"></a>        subsample <span class="op">=</span> msg[<span class="st">"value"</span>]</span>
<span id="cb45-77"><a href="#cb45-77" aria-hidden="true" tabindex="-1"></a>        subsample_size <span class="op">=</span> msg[<span class="st">"args"</span>][<span class="dv">1</span>]</span>
<span id="cb45-78"><a href="#cb45-78" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> subsample_size <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span> <span class="kw">and</span> subsample_size <span class="op">!=</span> subsample.shape[<span class="dv">0</span>]:</span>
<span id="cb45-79"><a href="#cb45-79" aria-hidden="true" tabindex="-1"></a>            warnings.warn(</span>
<span id="cb45-80"><a href="#cb45-80" aria-hidden="true" tabindex="-1"></a>                <span class="st">"subsample_size does not match len(subsample), </span><span class="sc">{}</span><span class="st"> vs </span><span class="sc">{}</span><span class="st">."</span>.<span class="bu">format</span>(</span>
<span id="cb45-81"><a href="#cb45-81" aria-hidden="true" tabindex="-1"></a>                    subsample_size, <span class="bu">len</span>(subsample)</span>
<span id="cb45-82"><a href="#cb45-82" aria-hidden="true" tabindex="-1"></a>                )</span>
<span id="cb45-83"><a href="#cb45-83" aria-hidden="true" tabindex="-1"></a>                <span class="op">+</span> <span class="st">" Did you accidentally use different subsample_size in the model and guide?"</span>,</span>
<span id="cb45-84"><a href="#cb45-84" aria-hidden="true" tabindex="-1"></a>                stacklevel<span class="op">=</span>find_stack_level(),</span>
<span id="cb45-85"><a href="#cb45-85" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb45-86"><a href="#cb45-86" aria-hidden="true" tabindex="-1"></a>        dep_stack <span class="op">=</span> msg[<span class="st">"dep_stack"</span>]</span>
<span id="cb45-87"><a href="#cb45-87" aria-hidden="true" tabindex="-1"></a>        occupied_dims <span class="op">=</span> {f.dim <span class="cf">for</span> f <span class="kw">in</span> dep_stack}</span>
<span id="cb45-88"><a href="#cb45-88" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> dim <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb45-89"><a href="#cb45-89" aria-hidden="true" tabindex="-1"></a>            new_dim <span class="op">=</span> <span class="op">-</span><span class="dv">1</span></span>
<span id="cb45-90"><a href="#cb45-90" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span> new_dim <span class="kw">in</span> occupied_dims:</span>
<span id="cb45-91"><a href="#cb45-91" aria-hidden="true" tabindex="-1"></a>                new_dim <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb45-92"><a href="#cb45-92" aria-hidden="true" tabindex="-1"></a>            dim <span class="op">=</span> new_dim</span>
<span id="cb45-93"><a href="#cb45-93" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb45-94"><a href="#cb45-94" aria-hidden="true" tabindex="-1"></a>            <span class="cf">assert</span> dim <span class="kw">not</span> <span class="kw">in</span> occupied_dims</span>
<span id="cb45-95"><a href="#cb45-95" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dim, subsample</span>
<span id="cb45-96"><a href="#cb45-96" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-97"><a href="#cb45-97" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-98"><a href="#cb45-98" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> test_model_batches():</span>
<span id="cb45-99"><a href="#cb45-99" aria-hidden="true" tabindex="-1"></a>    n_groups <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb45-100"><a href="#cb45-100" aria-hidden="true" tabindex="-1"></a>    <span class="cf">with</span> pseudo_plate(<span class="st">"groups"</span>, n_groups), numpyro.plate(<span class="st">"batches"</span>, <span class="dv">3</span>):</span>
<span id="cb45-101"><a href="#cb45-101" aria-hidden="true" tabindex="-1"></a>        gamma <span class="op">=</span> numpyro.sample(<span class="st">"gamma"</span>, dist.ZeroSumNormal(<span class="dv">1</span>, event_shape<span class="op">=</span>(n_groups,)))</span>
<span id="cb45-102"><a href="#cb45-102" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-103"><a href="#cb45-103" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-104"><a href="#cb45-104" aria-hidden="true" tabindex="-1"></a>trace <span class="op">=</span> jax.eval_shape(partial(get_trace, test_model_batches, model_kwargs<span class="op">=</span>{})).trace</span>
<span id="cb45-105"><a href="#cb45-105" aria-hidden="true" tabindex="-1"></a>trace[<span class="st">'gamma'</span>][<span class="st">'value'</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="23">
<pre><code>ShapeDtypeStruct(shape=(3, 10), dtype=float32)</code></pre>
</div>
</div>
<p>Perfect this works, we just need to combine our two plate stacks!</p>
<div id="d9567cb6" class="cell" data-execution_count="24">
<div class="sourceCode cell-code" id="cb47"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a>trace[<span class="st">'gamma'</span>][<span class="st">'cond_indep_stack'</span>] <span class="op">+</span> trace[<span class="st">'gamma'</span>][<span class="st">'dep_stack'</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="24">
<pre><code>[CondIndepStackFrame(name='batches', dim=-1, size=3),
 DepStackFrame(name='groups', dim=-1, size=10)]</code></pre>
</div>
</div>
</section>
<section id="the-resulting-implementation" class="level1">
<h1>The resulting implementation</h1>
<p>Finally, lets bring this altogether. In the code-fold below is all of the needed functions in one place</p>
<div id="9e5d19c1" class="cell" data-execution_count="25">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb49"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> typing <span class="im">import</span> Tuple, Any, Optional, List, Dict, Callable</span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> namedtuple</span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> numpy.typing <span class="im">import</span> ArrayLike</span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> functools <span class="im">import</span> partial</span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb49-7"><a href="#cb49-7" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpyro</span>
<span id="cb49-8"><a href="#cb49-8" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> numpyro <span class="im">import</span> distributions <span class="im">as</span> dist</span>
<span id="cb49-9"><a href="#cb49-9" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> numpyro <span class="im">import</span> handlers</span>
<span id="cb49-10"><a href="#cb49-10" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> numpyro.primitives <span class="im">import</span> Messenger, apply_stack, _subsample_fn</span>
<span id="cb49-11"><a href="#cb49-11" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> numpyro.util <span class="im">import</span> find_stack_level</span>
<span id="cb49-12"><a href="#cb49-12" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> numpyro.infer <span class="im">import</span> NUTS, MCMC</span>
<span id="cb49-13"><a href="#cb49-13" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> numpyro.infer.initialization <span class="im">import</span> init_to_sample</span>
<span id="cb49-14"><a href="#cb49-14" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> numpyro.ops.pytree <span class="im">import</span> PytreeTrace</span>
<span id="cb49-15"><a href="#cb49-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-16"><a href="#cb49-16" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> jax</span>
<span id="cb49-17"><a href="#cb49-17" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> jax <span class="im">import</span> random</span>
<span id="cb49-18"><a href="#cb49-18" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> jax.numpy <span class="im">as</span> jnp</span>
<span id="cb49-19"><a href="#cb49-19" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> jaxtyping <span class="im">import</span> Float, Array, Int</span>
<span id="cb49-20"><a href="#cb49-20" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> arviz <span class="im">as</span> az</span>
<span id="cb49-21"><a href="#cb49-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-22"><a href="#cb49-22" aria-hidden="true" tabindex="-1"></a><span class="co"># #######################</span></span>
<span id="cb49-23"><a href="#cb49-23" aria-hidden="true" tabindex="-1"></a><span class="co"># Code for pseudo_plate</span></span>
<span id="cb49-24"><a href="#cb49-24" aria-hidden="true" tabindex="-1"></a><span class="co"># #######################</span></span>
<span id="cb49-25"><a href="#cb49-25" aria-hidden="true" tabindex="-1"></a>Message <span class="op">=</span> <span class="bu">dict</span>[<span class="bu">str</span>, Any]</span>
<span id="cb49-26"><a href="#cb49-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-27"><a href="#cb49-27" aria-hidden="true" tabindex="-1"></a>DepStackFrame <span class="op">=</span> namedtuple(<span class="st">"DepStackFrame"</span>, [<span class="st">"name"</span>, <span class="st">"dim"</span>, <span class="st">"size"</span>])</span>
<span id="cb49-28"><a href="#cb49-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-29"><a href="#cb49-29" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> pseudo_plate(numpyro.plate):</span>
<span id="cb49-30"><a href="#cb49-30" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb49-31"><a href="#cb49-31" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(</span>
<span id="cb49-32"><a href="#cb49-32" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>,</span>
<span id="cb49-33"><a href="#cb49-33" aria-hidden="true" tabindex="-1"></a>        name: <span class="bu">str</span>,</span>
<span id="cb49-34"><a href="#cb49-34" aria-hidden="true" tabindex="-1"></a>        size: <span class="bu">int</span>,</span>
<span id="cb49-35"><a href="#cb49-35" aria-hidden="true" tabindex="-1"></a>        subsample_size: Optional[<span class="bu">int</span>] <span class="op">=</span> <span class="va">None</span>,</span>
<span id="cb49-36"><a href="#cb49-36" aria-hidden="true" tabindex="-1"></a>        dim: Optional[<span class="bu">int</span>] <span class="op">=</span> <span class="va">None</span>,</span>
<span id="cb49-37"><a href="#cb49-37" aria-hidden="true" tabindex="-1"></a>    ) <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb49-38"><a href="#cb49-38" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.name <span class="op">=</span> name</span>
<span id="cb49-39"><a href="#cb49-39" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.size <span class="op">=</span> size</span>
<span id="cb49-40"><a href="#cb49-40" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> dim <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span> <span class="kw">and</span> dim <span class="op">&gt;=</span> <span class="dv">0</span>:</span>
<span id="cb49-41"><a href="#cb49-41" aria-hidden="true" tabindex="-1"></a>            <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">"dim arg must be negative."</span>)</span>
<span id="cb49-42"><a href="#cb49-42" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.dim, <span class="va">self</span>._indices <span class="op">=</span> <span class="va">self</span>._subsample(</span>
<span id="cb49-43"><a href="#cb49-43" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.name, <span class="va">self</span>.size, subsample_size, dim</span>
<span id="cb49-44"><a href="#cb49-44" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb49-45"><a href="#cb49-45" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.subsample_size <span class="op">=</span> <span class="va">self</span>._indices.shape[<span class="dv">0</span>]</span>
<span id="cb49-46"><a href="#cb49-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-47"><a href="#cb49-47" aria-hidden="true" tabindex="-1"></a>    <span class="co"># We'll try only adding our pseudoplate to the CondIndepStack without doing anything else</span></span>
<span id="cb49-48"><a href="#cb49-48" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> process_message(<span class="va">self</span>, msg: Message) <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb49-49"><a href="#cb49-49" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> msg[<span class="st">"type"</span>] <span class="kw">not</span> <span class="kw">in</span> (<span class="st">"param"</span>, <span class="st">"sample"</span>, <span class="st">"plate"</span>, <span class="st">"deterministic"</span>):</span>
<span id="cb49-50"><a href="#cb49-50" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> msg[<span class="st">"type"</span>] <span class="op">==</span> <span class="st">"control_flow"</span>:</span>
<span id="cb49-51"><a href="#cb49-51" aria-hidden="true" tabindex="-1"></a>                <span class="cf">raise</span> <span class="pp">NotImplementedError</span>(</span>
<span id="cb49-52"><a href="#cb49-52" aria-hidden="true" tabindex="-1"></a>                    <span class="st">"Cannot use control flow primitive under a `plate` primitive."</span></span>
<span id="cb49-53"><a href="#cb49-53" aria-hidden="true" tabindex="-1"></a>                    <span class="st">" Please move those `plate` statements into the control flow"</span></span>
<span id="cb49-54"><a href="#cb49-54" aria-hidden="true" tabindex="-1"></a>                    <span class="st">" body function. See `scan` documentation for more information."</span></span>
<span id="cb49-55"><a href="#cb49-55" aria-hidden="true" tabindex="-1"></a>                )</span>
<span id="cb49-56"><a href="#cb49-56" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span></span>
<span id="cb49-57"><a href="#cb49-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-58"><a href="#cb49-58" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (</span>
<span id="cb49-59"><a href="#cb49-59" aria-hidden="true" tabindex="-1"></a>            <span class="st">"block_plates"</span> <span class="kw">in</span> msg.get(<span class="st">"infer"</span>, {})</span>
<span id="cb49-60"><a href="#cb49-60" aria-hidden="true" tabindex="-1"></a>            <span class="kw">and</span> <span class="va">self</span>.name <span class="kw">in</span> msg[<span class="st">"infer"</span>][<span class="st">"block_plates"</span>]</span>
<span id="cb49-61"><a href="#cb49-61" aria-hidden="true" tabindex="-1"></a>        ):</span>
<span id="cb49-62"><a href="#cb49-62" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span></span>
<span id="cb49-63"><a href="#cb49-63" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb49-64"><a href="#cb49-64" aria-hidden="true" tabindex="-1"></a>        frame <span class="op">=</span> DepStackFrame(<span class="va">self</span>.name, <span class="va">self</span>.dim, <span class="va">self</span>.subsample_size)</span>
<span id="cb49-65"><a href="#cb49-65" aria-hidden="true" tabindex="-1"></a>        msg[<span class="st">'dep_stack'</span>] <span class="op">=</span> msg.get(<span class="st">'dep_stack'</span>, []) <span class="op">+</span> [frame]</span>
<span id="cb49-66"><a href="#cb49-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-67"><a href="#cb49-67" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> msg[<span class="st">"type"</span>] <span class="op">==</span> <span class="st">"deterministic"</span>:</span>
<span id="cb49-68"><a href="#cb49-68" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span></span>
<span id="cb49-69"><a href="#cb49-69" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-70"><a href="#cb49-70" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _get_event_shape(<span class="va">self</span>, dep_stack: List[DepStackFrame]) <span class="op">-&gt;</span> Tuple[<span class="bu">int</span>]:</span>
<span id="cb49-71"><a href="#cb49-71" aria-hidden="true" tabindex="-1"></a>        n_dims <span class="op">=</span> <span class="bu">max</span>(<span class="op">-</span>f.dim <span class="cf">for</span> f <span class="kw">in</span> dep_stack)</span>
<span id="cb49-72"><a href="#cb49-72" aria-hidden="true" tabindex="-1"></a>        event_shape <span class="op">=</span> [<span class="dv">1</span>] <span class="op">*</span> n_dims</span>
<span id="cb49-73"><a href="#cb49-73" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> f <span class="kw">in</span> dep_stack:</span>
<span id="cb49-74"><a href="#cb49-74" aria-hidden="true" tabindex="-1"></a>            event_shape[f.dim] <span class="op">=</span> f.size</span>
<span id="cb49-75"><a href="#cb49-75" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">tuple</span>(event_shape)</span>
<span id="cb49-76"><a href="#cb49-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-77"><a href="#cb49-77" aria-hidden="true" tabindex="-1"></a>    <span class="co"># We need to make sure dims get aranged properly when there are multiple plates</span></span>
<span id="cb49-78"><a href="#cb49-78" aria-hidden="true" tabindex="-1"></a>    <span class="at">@staticmethod</span></span>
<span id="cb49-79"><a href="#cb49-79" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _subsample(name, size, subsample_size, dim):</span>
<span id="cb49-80"><a href="#cb49-80" aria-hidden="true" tabindex="-1"></a>        msg <span class="op">=</span> {</span>
<span id="cb49-81"><a href="#cb49-81" aria-hidden="true" tabindex="-1"></a>            <span class="st">"type"</span>: <span class="st">"plate"</span>,</span>
<span id="cb49-82"><a href="#cb49-82" aria-hidden="true" tabindex="-1"></a>            <span class="st">"fn"</span>: _subsample_fn,</span>
<span id="cb49-83"><a href="#cb49-83" aria-hidden="true" tabindex="-1"></a>            <span class="st">"name"</span>: name,</span>
<span id="cb49-84"><a href="#cb49-84" aria-hidden="true" tabindex="-1"></a>            <span class="st">"args"</span>: (size, subsample_size),</span>
<span id="cb49-85"><a href="#cb49-85" aria-hidden="true" tabindex="-1"></a>            <span class="st">"kwargs"</span>: {<span class="st">"rng_key"</span>: <span class="va">None</span>},</span>
<span id="cb49-86"><a href="#cb49-86" aria-hidden="true" tabindex="-1"></a>            <span class="st">"value"</span>: (</span>
<span id="cb49-87"><a href="#cb49-87" aria-hidden="true" tabindex="-1"></a>                <span class="va">None</span></span>
<span id="cb49-88"><a href="#cb49-88" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> (subsample_size <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span> <span class="kw">and</span> size <span class="op">!=</span> subsample_size)</span>
<span id="cb49-89"><a href="#cb49-89" aria-hidden="true" tabindex="-1"></a>                <span class="cf">else</span> jnp.arange(size)</span>
<span id="cb49-90"><a href="#cb49-90" aria-hidden="true" tabindex="-1"></a>            ),</span>
<span id="cb49-91"><a href="#cb49-91" aria-hidden="true" tabindex="-1"></a>            <span class="st">"scale"</span>: <span class="fl">1.0</span>,</span>
<span id="cb49-92"><a href="#cb49-92" aria-hidden="true" tabindex="-1"></a>            <span class="st">"cond_indep_stack"</span>: [],</span>
<span id="cb49-93"><a href="#cb49-93" aria-hidden="true" tabindex="-1"></a>            <span class="st">"dep_stack"</span>: [],</span>
<span id="cb49-94"><a href="#cb49-94" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb49-95"><a href="#cb49-95" aria-hidden="true" tabindex="-1"></a>        apply_stack(msg)</span>
<span id="cb49-96"><a href="#cb49-96" aria-hidden="true" tabindex="-1"></a>        subsample <span class="op">=</span> msg[<span class="st">"value"</span>]</span>
<span id="cb49-97"><a href="#cb49-97" aria-hidden="true" tabindex="-1"></a>        subsample_size <span class="op">=</span> msg[<span class="st">"args"</span>][<span class="dv">1</span>]</span>
<span id="cb49-98"><a href="#cb49-98" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> subsample_size <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span> <span class="kw">and</span> subsample_size <span class="op">!=</span> subsample.shape[<span class="dv">0</span>]:</span>
<span id="cb49-99"><a href="#cb49-99" aria-hidden="true" tabindex="-1"></a>            warnings.warn(</span>
<span id="cb49-100"><a href="#cb49-100" aria-hidden="true" tabindex="-1"></a>                <span class="st">"subsample_size does not match len(subsample), </span><span class="sc">{}</span><span class="st"> vs </span><span class="sc">{}</span><span class="st">."</span>.<span class="bu">format</span>(</span>
<span id="cb49-101"><a href="#cb49-101" aria-hidden="true" tabindex="-1"></a>                    subsample_size, <span class="bu">len</span>(subsample)</span>
<span id="cb49-102"><a href="#cb49-102" aria-hidden="true" tabindex="-1"></a>                )</span>
<span id="cb49-103"><a href="#cb49-103" aria-hidden="true" tabindex="-1"></a>                <span class="op">+</span> <span class="st">" Did you accidentally use different subsample_size in the model and guide?"</span>,</span>
<span id="cb49-104"><a href="#cb49-104" aria-hidden="true" tabindex="-1"></a>                stacklevel<span class="op">=</span>find_stack_level(),</span>
<span id="cb49-105"><a href="#cb49-105" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb49-106"><a href="#cb49-106" aria-hidden="true" tabindex="-1"></a>        dep_stack <span class="op">=</span> msg[<span class="st">"dep_stack"</span>]</span>
<span id="cb49-107"><a href="#cb49-107" aria-hidden="true" tabindex="-1"></a>        occupied_dims <span class="op">=</span> {f.dim <span class="cf">for</span> f <span class="kw">in</span> dep_stack}</span>
<span id="cb49-108"><a href="#cb49-108" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> dim <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb49-109"><a href="#cb49-109" aria-hidden="true" tabindex="-1"></a>            new_dim <span class="op">=</span> <span class="op">-</span><span class="dv">1</span></span>
<span id="cb49-110"><a href="#cb49-110" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span> new_dim <span class="kw">in</span> occupied_dims:</span>
<span id="cb49-111"><a href="#cb49-111" aria-hidden="true" tabindex="-1"></a>                new_dim <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb49-112"><a href="#cb49-112" aria-hidden="true" tabindex="-1"></a>            dim <span class="op">=</span> new_dim</span>
<span id="cb49-113"><a href="#cb49-113" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb49-114"><a href="#cb49-114" aria-hidden="true" tabindex="-1"></a>            <span class="cf">assert</span> dim <span class="kw">not</span> <span class="kw">in</span> occupied_dims</span>
<span id="cb49-115"><a href="#cb49-115" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dim, subsample</span>
<span id="cb49-116"><a href="#cb49-116" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-117"><a href="#cb49-117" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-118"><a href="#cb49-118" aria-hidden="true" tabindex="-1"></a><span class="co"># #######################</span></span>
<span id="cb49-119"><a href="#cb49-119" aria-hidden="true" tabindex="-1"></a><span class="co"># Code for pulling dims</span></span>
<span id="cb49-120"><a href="#cb49-120" aria-hidden="true" tabindex="-1"></a><span class="co"># #######################</span></span>
<span id="cb49-121"><a href="#cb49-121" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-122"><a href="#cb49-122" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_site_dims(model: Callable, <span class="op">**</span>kwargs):</span>
<span id="cb49-123"><a href="#cb49-123" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _get_dist_name(fn):</span>
<span id="cb49-124"><a href="#cb49-124" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">isinstance</span>(</span>
<span id="cb49-125"><a href="#cb49-125" aria-hidden="true" tabindex="-1"></a>            fn, (dist.Independent, dist.ExpandedDistribution, dist.MaskedDistribution)</span>
<span id="cb49-126"><a href="#cb49-126" aria-hidden="true" tabindex="-1"></a>        ):</span>
<span id="cb49-127"><a href="#cb49-127" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> _get_dist_name(fn.base_dist)</span>
<span id="cb49-128"><a href="#cb49-128" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">type</span>(fn).<span class="va">__name__</span></span>
<span id="cb49-129"><a href="#cb49-129" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-130"><a href="#cb49-130" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> get_trace():</span>
<span id="cb49-131"><a href="#cb49-131" aria-hidden="true" tabindex="-1"></a>        <span class="co"># We use `init_to_sample` to get around ImproperUniform distribution,</span></span>
<span id="cb49-132"><a href="#cb49-132" aria-hidden="true" tabindex="-1"></a>        <span class="co"># which does not have `sample` method.</span></span>
<span id="cb49-133"><a href="#cb49-133" aria-hidden="true" tabindex="-1"></a>        subs_model <span class="op">=</span> handlers.substitute(</span>
<span id="cb49-134"><a href="#cb49-134" aria-hidden="true" tabindex="-1"></a>            handlers.seed(model, <span class="dv">0</span>),</span>
<span id="cb49-135"><a href="#cb49-135" aria-hidden="true" tabindex="-1"></a>            substitute_fn<span class="op">=</span>init_to_sample,</span>
<span id="cb49-136"><a href="#cb49-136" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb49-137"><a href="#cb49-137" aria-hidden="true" tabindex="-1"></a>        trace <span class="op">=</span> handlers.trace(subs_model).get_trace(<span class="op">**</span>kwargs)</span>
<span id="cb49-138"><a href="#cb49-138" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Work around an issue where jax.eval_shape does not work</span></span>
<span id="cb49-139"><a href="#cb49-139" aria-hidden="true" tabindex="-1"></a>        <span class="co"># for distribution output (e.g. the function `lambda: dist.Normal(0, 1)`)</span></span>
<span id="cb49-140"><a href="#cb49-140" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Here we will remove `fn` and store its name in the trace.</span></span>
<span id="cb49-141"><a href="#cb49-141" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> name, site <span class="kw">in</span> trace.items():</span>
<span id="cb49-142"><a href="#cb49-142" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> site[<span class="st">"type"</span>] <span class="op">==</span> <span class="st">"sample"</span>:</span>
<span id="cb49-143"><a href="#cb49-143" aria-hidden="true" tabindex="-1"></a>                site[<span class="st">"fn_name"</span>] <span class="op">=</span> _get_dist_name(site.pop(<span class="st">"fn"</span>))</span>
<span id="cb49-144"><a href="#cb49-144" aria-hidden="true" tabindex="-1"></a>            <span class="cf">elif</span> site[<span class="st">"type"</span>] <span class="op">==</span> <span class="st">"deterministic"</span>:</span>
<span id="cb49-145"><a href="#cb49-145" aria-hidden="true" tabindex="-1"></a>                site[<span class="st">"fn_name"</span>] <span class="op">=</span> <span class="st">"Deterministic"</span></span>
<span id="cb49-146"><a href="#cb49-146" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> PytreeTrace(trace)</span>
<span id="cb49-147"><a href="#cb49-147" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-148"><a href="#cb49-148" aria-hidden="true" tabindex="-1"></a>    <span class="co"># We use eval_shape to avoid any array computation.</span></span>
<span id="cb49-149"><a href="#cb49-149" aria-hidden="true" tabindex="-1"></a>    trace <span class="op">=</span> jax.eval_shape(get_trace).trace</span>
<span id="cb49-150"><a href="#cb49-150" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-151"><a href="#cb49-151" aria-hidden="true" tabindex="-1"></a>    sample_plates <span class="op">=</span> {</span>
<span id="cb49-152"><a href="#cb49-152" aria-hidden="true" tabindex="-1"></a>        name: [frame.name <span class="cf">for</span> frame <span class="kw">in</span> site[<span class="st">"cond_indep_stack"</span>] <span class="op">+</span> site.get(<span class="st">"dep_stack"</span>, [])]</span>
<span id="cb49-153"><a href="#cb49-153" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> name, site <span class="kw">in</span> trace.items()</span>
<span id="cb49-154"><a href="#cb49-154" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> site[<span class="st">"type"</span>] <span class="kw">in</span> [<span class="st">"sample"</span>, <span class="st">"deterministic"</span>]</span>
<span id="cb49-155"><a href="#cb49-155" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb49-156"><a href="#cb49-156" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> {k:v <span class="cf">for</span> k,v <span class="kw">in</span> sample_plates.items() <span class="cf">if</span> <span class="bu">len</span>(v) <span class="op">&gt;</span> <span class="dv">0</span>}</span>
<span id="cb49-157"><a href="#cb49-157" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-158"><a href="#cb49-158" aria-hidden="true" tabindex="-1"></a><span class="co"># helper function</span></span>
<span id="cb49-159"><a href="#cb49-159" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> print_site_dims(idata, <span class="bu">vars</span> <span class="op">=</span> [<span class="st">'alpha'</span>, <span class="st">'beta'</span>, <span class="st">'mu'</span>]):</span>
<span id="cb49-160"><a href="#cb49-160" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> var <span class="kw">in</span> <span class="bu">vars</span>:</span>
<span id="cb49-161"><a href="#cb49-161" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>var<span class="sc">}</span><span class="ss">:"</span>, idata.posterior[var].dims )</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>And the simulation code is underneath the following code-fold</p>
<div id="aff2dbb1" class="cell" data-execution_count="26">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb50"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="co"># #################</span></span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Simulation Code </span></span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a><span class="co"># #################</span></span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a>SEED: <span class="bu">int</span> <span class="op">=</span> <span class="dv">99</span></span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true" tabindex="-1"></a>rng <span class="op">=</span> np.random.default_rng(SEED)</span>
<span id="cb50-7"><a href="#cb50-7" aria-hidden="true" tabindex="-1"></a>N, n_feats <span class="op">=</span> <span class="dv">1000</span>, <span class="dv">3</span></span>
<span id="cb50-8"><a href="#cb50-8" aria-hidden="true" tabindex="-1"></a>z_cardinality <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb50-9"><a href="#cb50-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-10"><a href="#cb50-10" aria-hidden="true" tabindex="-1"></a>alpha <span class="op">=</span> <span class="fl">1.3</span></span>
<span id="cb50-11"><a href="#cb50-11" aria-hidden="true" tabindex="-1"></a>beta <span class="op">=</span> rng.normal(size<span class="op">=</span>n_feats)</span>
<span id="cb50-12"><a href="#cb50-12" aria-hidden="true" tabindex="-1"></a>gamma <span class="op">=</span> rng.normal(size<span class="op">=</span>z_cardinality)</span>
<span id="cb50-13"><a href="#cb50-13" aria-hidden="true" tabindex="-1"></a>sigma <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb50-14"><a href="#cb50-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-15"><a href="#cb50-15" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> rng.normal(size<span class="op">=</span>(N, n_feats))</span>
<span id="cb50-16"><a href="#cb50-16" aria-hidden="true" tabindex="-1"></a>z <span class="op">=</span> rng.choice(<span class="bu">range</span>(z_cardinality), size<span class="op">=</span>N)</span>
<span id="cb50-17"><a href="#cb50-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-18"><a href="#cb50-18" aria-hidden="true" tabindex="-1"></a>mu <span class="op">=</span> alpha <span class="op">+</span> np.dot(X, beta) <span class="op">+</span> gamma[z]</span>
<span id="cb50-19"><a href="#cb50-19" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> rng.normal(mu, sigma)</span>
<span id="cb50-20"><a href="#cb50-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-21"><a href="#cb50-21" aria-hidden="true" tabindex="-1"></a><span class="co"># beta = rng.normal(size=(z_cardinality, n_feats))</span></span>
<span id="cb50-22"><a href="#cb50-22" aria-hidden="true" tabindex="-1"></a><span class="co"># mu = alpha + (X * beta[z]).sum(-1) + gamma[z]</span></span>
<span id="cb50-23"><a href="#cb50-23" aria-hidden="true" tabindex="-1"></a><span class="co"># y = rng.normal(mu, sigma)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>And finally here’s how we’d actually use all of these tools</p>
<div id="dc5ed1bd" class="cell" data-execution_count="27">
<div class="sourceCode cell-code" id="cb51"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> run_inference(</span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a>    model: Callable,</span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a>    key: random.PRNGKey,</span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a>    num_warmup: <span class="bu">int</span> <span class="op">=</span> <span class="dv">100</span>, </span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a>    num_chains: <span class="bu">int</span> <span class="op">=</span> <span class="dv">2</span>, </span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a>    num_samples: <span class="bu">int</span> <span class="op">=</span> <span class="dv">100</span>,</span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true" tabindex="-1"></a>    coords: Dict[<span class="bu">str</span>, ArrayLike] <span class="op">=</span> <span class="va">None</span>,</span>
<span id="cb51-8"><a href="#cb51-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">**</span>kwargs</span>
<span id="cb51-9"><a href="#cb51-9" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> Tuple[MCMC, az.InferenceData]:</span>
<span id="cb51-10"><a href="#cb51-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-11"><a href="#cb51-11" aria-hidden="true" tabindex="-1"></a>    kernel <span class="op">=</span> NUTS(model)</span>
<span id="cb51-12"><a href="#cb51-12" aria-hidden="true" tabindex="-1"></a>    mcmc <span class="op">=</span> MCMC(kernel, num_warmup<span class="op">=</span>num_warmup, num_chains<span class="op">=</span>num_chains, num_samples<span class="op">=</span>num_samples, progress_bar<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb51-13"><a href="#cb51-13" aria-hidden="true" tabindex="-1"></a>    mcmc.run(key, <span class="op">**</span>kwargs)</span>
<span id="cb51-14"><a href="#cb51-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-15"><a href="#cb51-15" aria-hidden="true" tabindex="-1"></a>    dims <span class="op">=</span> get_site_dims(model, <span class="op">**</span>kwargs)</span>
<span id="cb51-16"><a href="#cb51-16" aria-hidden="true" tabindex="-1"></a>    idata <span class="op">=</span> az.from_numpyro(mcmc, coords<span class="op">=</span>coords, dims<span class="op">=</span>dims)</span>
<span id="cb51-17"><a href="#cb51-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> mcmc, idata</span>
<span id="cb51-18"><a href="#cb51-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-19"><a href="#cb51-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-20"><a href="#cb51-20" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> model(</span>
<span id="cb51-21"><a href="#cb51-21" aria-hidden="true" tabindex="-1"></a>    X: Float[Array, <span class="st">"obs features"</span>], </span>
<span id="cb51-22"><a href="#cb51-22" aria-hidden="true" tabindex="-1"></a>    Z: Float[Array, <span class="st">" obs"</span>], </span>
<span id="cb51-23"><a href="#cb51-23" aria-hidden="true" tabindex="-1"></a>    y: Float[Array, <span class="st">" obs"</span>] <span class="op">=</span> <span class="va">None</span>,</span>
<span id="cb51-24"><a href="#cb51-24" aria-hidden="true" tabindex="-1"></a>    try_pseudo_plate <span class="op">=</span> <span class="va">True</span>,</span>
<span id="cb51-25"><a href="#cb51-25" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> Float[Array, <span class="st">" obs"</span>]:</span>
<span id="cb51-26"><a href="#cb51-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-27"><a href="#cb51-27" aria-hidden="true" tabindex="-1"></a>    feature_plate <span class="op">=</span> numpyro.plate(<span class="st">"features"</span>, X.shape[<span class="op">-</span><span class="dv">1</span>], dim<span class="op">=-</span><span class="dv">2</span>)</span>
<span id="cb51-28"><a href="#cb51-28" aria-hidden="true" tabindex="-1"></a>    group_plate <span class="op">=</span> numpyro.plate(<span class="st">"Z"</span>, <span class="bu">len</span>(np.unique(Z)), dim<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb51-29"><a href="#cb51-29" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb51-30"><a href="#cb51-30" aria-hidden="true" tabindex="-1"></a>    alpha <span class="op">=</span> numpyro.sample(<span class="st">"alpha"</span>, dist.Normal(<span class="dv">0</span>, <span class="dv">3</span>))</span>
<span id="cb51-31"><a href="#cb51-31" aria-hidden="true" tabindex="-1"></a>    sigma <span class="op">=</span> numpyro.sample(<span class="st">"sigma"</span>, dist.HalfNormal(<span class="dv">1</span>))</span>
<span id="cb51-32"><a href="#cb51-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">with</span> group_plate, feature_plate:</span>
<span id="cb51-33"><a href="#cb51-33" aria-hidden="true" tabindex="-1"></a>        beta <span class="op">=</span> numpyro.sample(<span class="st">"beta"</span>, dist.Normal(<span class="dv">0</span>, <span class="dv">1</span>))</span>
<span id="cb51-34"><a href="#cb51-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">with</span> pseudo_plate(<span class="st">"Z"</span>, group_plate.size):</span>
<span id="cb51-35"><a href="#cb51-35" aria-hidden="true" tabindex="-1"></a>        gamma <span class="op">=</span> numpyro.sample(<span class="st">"gamma"</span>, dist.ZeroSumNormal(<span class="dv">1</span>, event_shape<span class="op">=</span>(group_plate.size,)))</span>
<span id="cb51-36"><a href="#cb51-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-37"><a href="#cb51-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">with</span> numpyro.plate(<span class="st">"obs_id"</span>, X.shape[<span class="dv">0</span>]):</span>
<span id="cb51-38"><a href="#cb51-38" aria-hidden="true" tabindex="-1"></a>        mu <span class="op">=</span> numpyro.deterministic(<span class="st">"mu"</span>, alpha <span class="op">+</span> gamma[z] <span class="op">+</span> (X<span class="op">*</span>beta[:,z].T).<span class="bu">sum</span>(<span class="op">-</span><span class="dv">1</span>))</span>
<span id="cb51-39"><a href="#cb51-39" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> numpyro.sample(<span class="st">"y"</span>, dist.Normal(mu, sigma), obs<span class="op">=</span>y)</span>
<span id="cb51-40"><a href="#cb51-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-41"><a href="#cb51-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-42"><a href="#cb51-42" aria-hidden="true" tabindex="-1"></a>coords <span class="op">=</span> {</span>
<span id="cb51-43"><a href="#cb51-43" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Z"</span>: [<span class="ss">f'X</span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">'</span> <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, z_cardinality<span class="op">+</span><span class="dv">1</span>)],</span>
<span id="cb51-44"><a href="#cb51-44" aria-hidden="true" tabindex="-1"></a>    <span class="st">"obs_id"</span>: np.arange(N),</span>
<span id="cb51-45"><a href="#cb51-45" aria-hidden="true" tabindex="-1"></a>    <span class="st">"features"</span>: [<span class="ss">f'X</span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">'</span> <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n_feats<span class="op">+</span><span class="dv">1</span>)],</span>
<span id="cb51-46"><a href="#cb51-46" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb51-47"><a href="#cb51-47" aria-hidden="true" tabindex="-1"></a>model_kwargs <span class="op">=</span> <span class="bu">dict</span>(X<span class="op">=</span>X, Z<span class="op">=</span>z, y<span class="op">=</span>y)</span>
<span id="cb51-48"><a href="#cb51-48" aria-hidden="true" tabindex="-1"></a>mcmc, idata <span class="op">=</span> run_inference(model, random.PRNGKey(<span class="dv">0</span>), coords<span class="op">=</span>coords, <span class="op">**</span>model_kwargs)</span>
<span id="cb51-49"><a href="#cb51-49" aria-hidden="true" tabindex="-1"></a>print_site_dims(idata, <span class="bu">vars</span><span class="op">=</span>[<span class="st">'beta'</span>, <span class="st">'gamma'</span>, <span class="st">'mu'</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>beta: ('chain', 'draw', 'features', 'Z')
gamma: ('chain', 'draw', 'Z')
mu: ('chain', 'draw', 'obs_id')</code></pre>
</div>
</div>
<p>We can see above that the dims are all properly labelled, and below we can see them properly mapped to the coords provided</p>
<div id="a2e5e736" class="cell" data-execution_count="28">
<div class="sourceCode cell-code" id="cb53"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a>idata.posterior[<span class="st">'gamma'</span>].coords[<span class="st">'Z'</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="28">
<div><svg style="position: absolute; width: 0; height: 0; overflow: hidden">
<defs>
<symbol id="icon-database" viewbox="0 0 32 32">
<path d="M16 0c-8.837 0-16 2.239-16 5v4c0 2.761 7.163 5 16 5s16-2.239 16-5v-4c0-2.761-7.163-5-16-5z"></path>
<path d="M16 17c-8.837 0-16-2.239-16-5v6c0 2.761 7.163 5 16 5s16-2.239 16-5v-6c0 2.761-7.163 5-16 5z"></path>
<path d="M16 26c-8.837 0-16-2.239-16-5v6c0 2.761 7.163 5 16 5s16-2.239 16-5v-6c0 2.761-7.163 5-16 5z"></path>
</symbol>
<symbol id="icon-file-text2" viewbox="0 0 32 32">
<path d="M28.681 7.159c-0.694-0.947-1.662-2.053-2.724-3.116s-2.169-2.030-3.116-2.724c-1.612-1.182-2.393-1.319-2.841-1.319h-15.5c-1.378 0-2.5 1.121-2.5 2.5v27c0 1.378 1.122 2.5 2.5 2.5h23c1.378 0 2.5-1.122 2.5-2.5v-19.5c0-0.448-0.137-1.23-1.319-2.841zM24.543 5.457c0.959 0.959 1.712 1.825 2.268 2.543h-4.811v-4.811c0.718 0.556 1.584 1.309 2.543 2.268zM28 29.5c0 0.271-0.229 0.5-0.5 0.5h-23c-0.271 0-0.5-0.229-0.5-0.5v-27c0-0.271 0.229-0.5 0.5-0.5 0 0 15.499-0 15.5 0v7c0 0.552 0.448 1 1 1h7v19.5z"></path>
<path d="M23 26h-14c-0.552 0-1-0.448-1-1s0.448-1 1-1h14c0.552 0 1 0.448 1 1s-0.448 1-1 1z"></path>
<path d="M23 22h-14c-0.552 0-1-0.448-1-1s0.448-1 1-1h14c0.552 0 1 0.448 1 1s-0.448 1-1 1z"></path>
<path d="M23 18h-14c-0.552 0-1-0.448-1-1s0.448-1 1-1h14c0.552 0 1 0.448 1 1s-0.448 1-1 1z"></path>
</symbol>
</defs>
</svg>
<style>/* CSS stylesheet for displaying xarray objects in jupyterlab.
 *
 */

:root {
  --xr-font-color0: var(--jp-content-font-color0, rgba(0, 0, 0, 1));
  --xr-font-color2: var(--jp-content-font-color2, rgba(0, 0, 0, 0.54));
  --xr-font-color3: var(--jp-content-font-color3, rgba(0, 0, 0, 0.38));
  --xr-border-color: var(--jp-border-color2, #e0e0e0);
  --xr-disabled-color: var(--jp-layout-color3, #bdbdbd);
  --xr-background-color: var(--jp-layout-color0, white);
  --xr-background-color-row-even: var(--jp-layout-color1, white);
  --xr-background-color-row-odd: var(--jp-layout-color2, #eeeeee);
}

html[theme="dark"],
html[data-theme="dark"],
body[data-theme="dark"],
body.vscode-dark {
  --xr-font-color0: rgba(255, 255, 255, 1);
  --xr-font-color2: rgba(255, 255, 255, 0.54);
  --xr-font-color3: rgba(255, 255, 255, 0.38);
  --xr-border-color: #1f1f1f;
  --xr-disabled-color: #515151;
  --xr-background-color: #111111;
  --xr-background-color-row-even: #111111;
  --xr-background-color-row-odd: #313131;
}

.xr-wrap {
  display: block !important;
  min-width: 300px;
  max-width: 700px;
}

.xr-text-repr-fallback {
  /* fallback to plain text repr when CSS is not injected (untrusted notebook) */
  display: none;
}

.xr-header {
  padding-top: 6px;
  padding-bottom: 6px;
  margin-bottom: 4px;
  border-bottom: solid 1px var(--xr-border-color);
}

.xr-header > div,
.xr-header > ul {
  display: inline;
  margin-top: 0;
  margin-bottom: 0;
}

.xr-obj-type,
.xr-array-name {
  margin-left: 2px;
  margin-right: 10px;
}

.xr-obj-type {
  color: var(--xr-font-color2);
}

.xr-sections {
  padding-left: 0 !important;
  display: grid;
  grid-template-columns: 150px auto auto 1fr 0 20px 0 20px;
}

.xr-section-item {
  display: contents;
}

.xr-section-item input {
  display: inline-block;
  opacity: 0;
  height: 0;
}

.xr-section-item input + label {
  color: var(--xr-disabled-color);
}

.xr-section-item input:enabled + label {
  cursor: pointer;
  color: var(--xr-font-color2);
}

.xr-section-item input:focus + label {
  border: 2px solid var(--xr-font-color0);
}

.xr-section-item input:enabled + label:hover {
  color: var(--xr-font-color0);
}

.xr-section-summary {
  grid-column: 1;
  color: var(--xr-font-color2);
  font-weight: 500;
}

.xr-section-summary > span {
  display: inline-block;
  padding-left: 0.5em;
}

.xr-section-summary-in:disabled + label {
  color: var(--xr-font-color2);
}

.xr-section-summary-in + label:before {
  display: inline-block;
  content: "►";
  font-size: 11px;
  width: 15px;
  text-align: center;
}

.xr-section-summary-in:disabled + label:before {
  color: var(--xr-disabled-color);
}

.xr-section-summary-in:checked + label:before {
  content: "▼";
}

.xr-section-summary-in:checked + label > span {
  display: none;
}

.xr-section-summary,
.xr-section-inline-details {
  padding-top: 4px;
  padding-bottom: 4px;
}

.xr-section-inline-details {
  grid-column: 2 / -1;
}

.xr-section-details {
  display: none;
  grid-column: 1 / -1;
  margin-bottom: 5px;
}

.xr-section-summary-in:checked ~ .xr-section-details {
  display: contents;
}

.xr-array-wrap {
  grid-column: 1 / -1;
  display: grid;
  grid-template-columns: 20px auto;
}

.xr-array-wrap > label {
  grid-column: 1;
  vertical-align: top;
}

.xr-preview {
  color: var(--xr-font-color3);
}

.xr-array-preview,
.xr-array-data {
  padding: 0 5px !important;
  grid-column: 2;
}

.xr-array-data,
.xr-array-in:checked ~ .xr-array-preview {
  display: none;
}

.xr-array-in:checked ~ .xr-array-data,
.xr-array-preview {
  display: inline-block;
}

.xr-dim-list {
  display: inline-block !important;
  list-style: none;
  padding: 0 !important;
  margin: 0;
}

.xr-dim-list li {
  display: inline-block;
  padding: 0;
  margin: 0;
}

.xr-dim-list:before {
  content: "(";
}

.xr-dim-list:after {
  content: ")";
}

.xr-dim-list li:not(:last-child):after {
  content: ",";
  padding-right: 5px;
}

.xr-has-index {
  font-weight: bold;
}

.xr-var-list,
.xr-var-item {
  display: contents;
}

.xr-var-item > div,
.xr-var-item label,
.xr-var-item > .xr-var-name span {
  background-color: var(--xr-background-color-row-even);
  margin-bottom: 0;
}

.xr-var-item > .xr-var-name:hover span {
  padding-right: 5px;
}

.xr-var-list > li:nth-child(odd) > div,
.xr-var-list > li:nth-child(odd) > label,
.xr-var-list > li:nth-child(odd) > .xr-var-name span {
  background-color: var(--xr-background-color-row-odd);
}

.xr-var-name {
  grid-column: 1;
}

.xr-var-dims {
  grid-column: 2;
}

.xr-var-dtype {
  grid-column: 3;
  text-align: right;
  color: var(--xr-font-color2);
}

.xr-var-preview {
  grid-column: 4;
}

.xr-index-preview {
  grid-column: 2 / 5;
  color: var(--xr-font-color2);
}

.xr-var-name,
.xr-var-dims,
.xr-var-dtype,
.xr-preview,
.xr-attrs dt {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  padding-right: 10px;
}

.xr-var-name:hover,
.xr-var-dims:hover,
.xr-var-dtype:hover,
.xr-attrs dt:hover {
  overflow: visible;
  width: auto;
  z-index: 1;
}

.xr-var-attrs,
.xr-var-data,
.xr-index-data {
  display: none;
  background-color: var(--xr-background-color) !important;
  padding-bottom: 5px !important;
}

.xr-var-attrs-in:checked ~ .xr-var-attrs,
.xr-var-data-in:checked ~ .xr-var-data,
.xr-index-data-in:checked ~ .xr-index-data {
  display: block;
}

.xr-var-data > table {
  float: right;
}

.xr-var-name span,
.xr-var-data,
.xr-index-name div,
.xr-index-data,
.xr-attrs {
  padding-left: 25px !important;
}

.xr-attrs,
.xr-var-attrs,
.xr-var-data,
.xr-index-data {
  grid-column: 1 / -1;
}

dl.xr-attrs {
  padding: 0;
  margin: 0;
  display: grid;
  grid-template-columns: 125px auto;
}

.xr-attrs dt,
.xr-attrs dd {
  padding: 0;
  margin: 0;
  float: left;
  padding-right: 10px;
  width: auto;
}

.xr-attrs dt {
  font-weight: normal;
  grid-column: 1;
}

.xr-attrs dt:hover span {
  display: inline-block;
  background: var(--xr-background-color);
  padding-right: 10px;
}

.xr-attrs dd {
  grid-column: 2;
  white-space: pre-wrap;
  word-break: break-all;
}

.xr-icon-database,
.xr-icon-file-text2,
.xr-no-icon {
  display: inline-block;
  vertical-align: middle;
  width: 1em;
  height: 1.5em !important;
  stroke-width: 0;
  stroke: currentColor;
  fill: currentColor;
}
</style><pre class="xr-text-repr-fallback">&lt;xarray.DataArray 'Z' (Z: 10)&gt; Size: 120B
array(['X1', 'X2', 'X3', 'X4', 'X5', 'X6', 'X7', 'X8', 'X9', 'X10'],
      dtype='&lt;U3')
Coordinates:
  * Z        (Z) &lt;U3 120B 'X1' 'X2' 'X3' 'X4' 'X5' 'X6' 'X7' 'X8' 'X9' 'X10'</pre><div class="xr-wrap" style="display:none"><div class="xr-header"><div class="xr-obj-type">xarray.DataArray</div><div class="xr-array-name">'Z'</div><ul class="xr-dim-list"><li><span class="xr-has-index">Z</span>: 10</li></ul></div><ul class="xr-sections"><li class="xr-section-item"><div class="xr-array-wrap"><input id="section-d673e23f-8969-4bba-a9c9-819997ddd25b" class="xr-array-in" type="checkbox" checked=""><label for="section-d673e23f-8969-4bba-a9c9-819997ddd25b" title="Show/hide data repr"><svg class="icon xr-icon-database"><use href="#icon-database"></use></svg></label><div class="xr-array-preview xr-preview"><span>'X1' 'X2' 'X3' 'X4' 'X5' 'X6' 'X7' 'X8' 'X9' 'X10'</span></div><div class="xr-array-data"><pre>array(['X1', 'X2', 'X3', 'X4', 'X5', 'X6', 'X7', 'X8', 'X9', 'X10'],
      dtype='&lt;U3')</pre></div></div></li><li class="xr-section-item"><input id="section-c47fc7e3-37ad-4331-8145-fa193bc8c41b" class="xr-section-summary-in" type="checkbox" checked=""><label for="section-c47fc7e3-37ad-4331-8145-fa193bc8c41b" class="xr-section-summary">Coordinates: <span>(1)</span></label><div class="xr-section-inline-details"></div><div class="xr-section-details"><ul class="xr-var-list"><li class="xr-var-item"><div class="xr-var-name"><span class="xr-has-index">Z</span></div><div class="xr-var-dims">(Z)</div><div class="xr-var-dtype">&lt;U3</div><div class="xr-var-preview xr-preview">'X1' 'X2' 'X3' ... 'X8' 'X9' 'X10'</div><input id="attrs-16273181-a42a-4bce-a704-47c365207719" class="xr-var-attrs-in" type="checkbox" disabled=""><label for="attrs-16273181-a42a-4bce-a704-47c365207719" title="Show/Hide attributes"><svg class="icon xr-icon-file-text2"><use href="#icon-file-text2"></use></svg></label><input id="data-eae5cd3f-dad0-4c8f-b9f0-ae02590d8172" class="xr-var-data-in" type="checkbox"><label for="data-eae5cd3f-dad0-4c8f-b9f0-ae02590d8172" title="Show/Hide data repr"><svg class="icon xr-icon-database"><use href="#icon-database"></use></svg></label><div class="xr-var-attrs"><dl class="xr-attrs"></dl></div><div class="xr-var-data"><pre>array(['X1', 'X2', 'X3', 'X4', 'X5', 'X6', 'X7', 'X8', 'X9', 'X10'],
      dtype='&lt;U3')</pre></div></li></ul></div></li><li class="xr-section-item"><input id="section-5147fda7-3a73-4981-83d0-814e073a5eb3" class="xr-section-summary-in" type="checkbox"><label for="section-5147fda7-3a73-4981-83d0-814e073a5eb3" class="xr-section-summary">Indexes: <span>(1)</span></label><div class="xr-section-inline-details"></div><div class="xr-section-details"><ul class="xr-var-list"><li class="xr-var-item"><div class="xr-index-name"><div>Z</div></div><div class="xr-index-preview">PandasIndex</div><input type="checkbox" disabled=""><label></label><input id="index-0ee3ae32-ec48-4bdd-b0b9-b2b9eb906e50" class="xr-index-data-in" type="checkbox"><label for="index-0ee3ae32-ec48-4bdd-b0b9-b2b9eb906e50" title="Show/Hide index repr"><svg class="icon xr-icon-database"><use href="#icon-database"></use></svg></label><div class="xr-index-data"><pre>PandasIndex(Index(['X1', 'X2', 'X3', 'X4', 'X5', 'X6', 'X7', 'X8', 'X9', 'X10'], dtype='object', name='Z'))</pre></div></li></ul></div></li><li class="xr-section-item"><input id="section-43f069dd-6e4a-4a7b-9b5b-b297efbd5129" class="xr-section-summary-in" type="checkbox" disabled=""><label for="section-43f069dd-6e4a-4a7b-9b5b-b297efbd5129" class="xr-section-summary" title="Expand/collapse section">Attributes: <span>(0)</span></label><div class="xr-section-inline-details"></div><div class="xr-section-details"><dl class="xr-attrs"></dl></div></li></ul></div></div>
</div>
</div>
</section>
<section id="conclusion" class="level1">
<h1>Conclusion</h1>
<p>This was alot more difficult than I thought, and there are no guarantees this is a stable implementation since I’m working with very low level code, but I’m hoping this is a solid implementation to get cleaner model output from numpyro models. I’d likely want to reorganize all of this code and run more tests against it when I end up using it in my future projects, and I’d be curious if the numpyro devs had any easier ideas for how to pull this off.</p>
<p>Some things that still need to be explored are:</p>
<ol type="1">
<li>Will this still work when there’s scoping with sub-models? Or integration with other libraries like flax?</li>
<li>What changes need to be made to get this approach extended to SVI?</li>
</ol>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/kylejcaron\.github\.io\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>